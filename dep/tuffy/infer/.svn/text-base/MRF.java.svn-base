package tuffy.infer;

import java.util.ArrayList;
import java.util.BitSet;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Map;
import java.util.Random;
import java.util.WeakHashMap;
import java.util.concurrent.ConcurrentHashMap;

import tuffy.infer.ds.GAtom;
import tuffy.infer.ds.GClause;
import tuffy.infer.ds.KeyBlock;
import tuffy.learn.Learner;
import tuffy.mln.Clause;
import tuffy.mln.MarkovLogicNetwork;
import tuffy.sample.DS_JunctionTree;
import tuffy.sample.SampleAlgorithm_MCSAT;
import tuffy.sample.SampleAlgorithm_MetropolisHastingsSampling;
import tuffy.sample.SampleAlgorithm_NaiveSampling;
import tuffy.sample.SampleAlgorithm_SerialMixture;
import tuffy.util.BitSetIntPair;
import tuffy.util.Config;
import tuffy.util.DebugMan;
import tuffy.util.ExceptionMan;
import tuffy.util.HashArray;
import tuffy.util.Timer;
import tuffy.util.UIMan;
import tuffy.util.myInt;
import tuffy.worker.MLEWorker;
import tuffy.worker.MLEWorkerInstance;
import tuffy.worker.ds.MLEWorld;

/**
 * In-memory data structure representing an MRF.
 * 
 */
public class MRF {

	public static enum INIT_STRATEGY {ALL_FALSE, COIN_FLIP, GREEDY, COPY_LOW, TRAINING_DATA, NO_CHANGE};
	public INIT_STRATEGY initStrategy = INIT_STRATEGY.COIN_FLIP;

	public INIT_STRATEGY getInitStrategy(){
		return initStrategy;
	}

	public void setInitStrategy(INIT_STRATEGY strategy){
		initStrategy = strategy;
	}

	public KeyBlock keyBlock = new KeyBlock();

	public boolean isInfered = false;

	public synchronized boolean getInferAndFlipIfIsFalse() {
		if(isInfered == false){
			isInfered = true;
			return false;
		}else{
			return true;
		}
	} 

	/**
	 * Map from GAtom ID to GAtom object.
	 */
	public HashMap<Integer, GAtom> atoms = new HashMap<Integer, GAtom>();

	public boolean ownsAllAtoms = false;

	// TODO: blocking
	private boolean usingBlocks = false;

	private HashSet<Integer> coreAtoms = new HashSet<Integer>();

	/**
	 * Array of all GClause objects in this MRF.
	 */
	public ArrayList<GClause> clauses = new ArrayList<GClause>();

	HashMap<Integer, GClause> singletons = null;

	public HashMap<BitSet, myInt> mleTallies = new HashMap<BitSet, myInt>();


	/**
	 * Experiment reporting
	 */

	double expInferenceTime = 0;
	ArrayList<Double> expPrimalCosts = new ArrayList<Double>();
	ArrayList<Double> expDualCosts = new ArrayList<Double>();

	/**
	 * Data structures for fast cost calculation for MLE inference.
	 */
	public double[] bitmaps_weight;
	public BitSet[] bitmaps_signature;
	public BitSet[] bitmaps_mask;
	public Object[] clauseToFFCID;

	public BitSet empty = new BitSet();
	public boolean isCompiled = false;
	public String clausesSignature = null;

	public HashMap<GAtom, Integer> localAtomID = new HashMap<GAtom, Integer>();
	public HashMap<Integer, GAtom> globalAtom = new HashMap<Integer, GAtom>();
	public ConcurrentHashMap<Integer, BitSet> localAtomToUnitBitmap =
			new ConcurrentHashMap<Integer, BitSet>();

	public HashSet<Integer> isQueryForLearning = new HashSet<Integer>();
	public HashSet<Integer> isFiexedForLearning = new HashSet<Integer>();

	public HashMap<Integer, HashSet<Integer>> localAtom2Clause = 
			new HashMap<Integer, HashSet<Integer>>();
	public HashMap<Integer, HashSet<Integer>> localClause2Atom = 
			new HashMap<Integer, HashSet<Integer>>();

	public HashMap<Integer, HashSet<Integer>> keyToLocalAtoms = 
			new HashMap<Integer, HashSet<Integer>>();
	public HashMap<Integer, HashSet<Integer>> localAtomsToKey = 
			new HashMap<Integer, HashSet<Integer>>();

	public ConcurrentHashMap<String, Double> cweights = null;

	public void updateWeight(Map<String, Double> currentWeight){
		int ct = 0;
		for(GClause gc : this.clauses){

			//System.out.print("*");

			double newWeight = 0;
			for(String ffcid : gc.ffcid){
				if(ffcid.startsWith("-")){
					if(currentWeight.containsKey(ffcid.substring(1))){
						newWeight -= currentWeight.get(ffcid.substring(1));
					}
				}else{
					if(currentWeight.containsKey(ffcid)){
						newWeight += currentWeight.get(ffcid);
					}else{
						newWeight += Config.hard_weight;
					}
				}
			}
			gc.weight = newWeight;

			BitSet bitmap_signature = new BitSet();
			BitSet bitmap_mask = new BitSet();


			for(int lit : gc.lits){
				int atomid = Math.abs(lit);
				int localID = this.localAtomID.get(this.atoms.get(atomid));

				if(lit > 0){
					bitmap_signature.set(localID);
				}
				bitmap_mask.set(localID);
			}

			bitmaps_signature[ct] = bitmap_signature;
			bitmaps_mask[ct] = bitmap_mask;
			bitmaps_weight[ct] = gc.weight;
			clauseToFFCID[ct] = gc.ffcid;

			ct++;

		}

	}

	/**
	 * compile current MRF into a set of bitmaps, so that the calculation of
	 * costs can be conducted efficiently.
	 */
	public void compile(HashMap<String, Double>... weights){

		//System.out.println("compile 1");

		// only compile once
		if(isCompiled){
			return;
		}

		bitmaps_weight = new double[clauses.size()];
		bitmaps_signature = new BitSet[clauses.size()];
		bitmaps_mask = new BitSet[clauses.size()];
		clauseToFFCID = new Object[clauses.size()];

		//System.out.println("compile 2");

		// assign each gatom with an id starts from 0
		int ct = 1;		// TODO: bugs
		for(Integer atom: this.coreAtoms){


			localAtomID.put(this.atoms.get(atom), ct);
			globalAtom.put(ct, this.atoms.get(atom));

			if(!(this.atoms.get(atom).isquery_evid)){
				this.isQueryForLearning.add(ct);
			}else{
				if(this.atoms.get(atom).truth){
					this.isFiexedForLearning.add(ct);
				}
			}

			BitSet tmp = new BitSet();
			tmp.set(ct);

			localAtomToUnitBitmap.put(ct, tmp);

			ct++;
		}

		//System.out.println("compile 3");

		// for each ground clause, compile it into one bitmaps
		//		clause: c1 v !c2 v c3   (there are other atoms c4 and c5)
		//		=> 10100 as signature, 11100 as mask
		// given a world T
		// sat = #1 in [ (T ^ 10100) v !(T v 10100) ] ^ 11100
		ct = 0;
		for(GClause gc : this.clauses){

			//System.out.print("*");

			if(weights.length != 0){
				double newWeight = 0;
				for(String ffcid : gc.ffcid){
					if(ffcid.startsWith("-")){
						newWeight -= weights[0].get(ffcid.substring(1));
					}else{
						newWeight += weights[0].get(ffcid);
					}
				}
				gc.weight = newWeight;
			}

			BitSet bitmap_signature = new BitSet();
			BitSet bitmap_mask = new BitSet();

			boolean iskey = true;

			ArrayList<Integer> tosetSignature = new ArrayList<Integer>();
			ArrayList<Integer> tosetMask = new ArrayList<Integer>();
			for(int lit : gc.lits){

				if(lit > 0){
					iskey = false;
				}

				int atomid = Math.abs(lit);
				int localID = this.localAtomID.get(this.atoms.get(atomid));

				if(lit > 0){
					bitmap_signature.set(localID);
				}
				bitmap_mask.set(localID);

				if(!localAtom2Clause.containsKey(localID)){
					localAtom2Clause.put(localID, new HashSet<Integer>());
				}
				if(!localClause2Atom.containsKey(ct)){
					localClause2Atom.put(ct, new HashSet<Integer>());
				}

				localAtom2Clause.get(localID).add(ct);
				localClause2Atom.get(ct).add(localID);	
			}

			if(iskey == true && gc.weight >= Config.hard_weight){
				for(int lit : gc.lits){
					int atomid = Math.abs(lit);
					int localID = this.localAtomID.get(this.atoms.get(atomid));

					if(!keyToLocalAtoms.containsKey(gc.id)){
						keyToLocalAtoms.put(gc.id, new HashSet<Integer>());
					}

					keyToLocalAtoms.get(gc.id).add(localID);

					if(!localAtomsToKey.containsKey(localID)){
						localAtomsToKey.put(localID, new HashSet<Integer>());
					}

					localAtomsToKey.get(localID).add(gc.id);

				}

			}

			bitmaps_signature[ct] = bitmap_signature;
			bitmaps_mask[ct] = bitmap_mask;

			bitmaps_weight[ct] = gc.weight;
			clauseToFFCID[ct] = gc.ffcid;

			ct++;

		}

		//System.out.println("compile 4");
		/*
		for(ct=0;ct < bitmaps_mask.length; ct++){
			BitSet mask = bitmaps_mask[ct];
			if(mask.getPositions().size() == 1 && bitmaps_weight[ct] > 0.1){
				UIMan.println("One");
			}
		}
		 */
	}



	/*
	public int nClause;
	public void compile_sgd(){

		nClause = 0;
		for(GClause gc : this.clauses){

			gc.f


		}
	}
	 */

	/**
	 * Given a possible world, returns the cost. <br />
	 * !!! IMPORTANT !!!
	 * Need the function {@link MRF::compile} to be invoked before. Due to efficiency
	 * considerations, this function does not check {@link MRF::isCompiled}.
	 * @param world
	 * @return
	 */
	public double getCost(BitSet world){
		double rs = 0;
		for(int ct=0;ct<bitmaps_weight.length;ct++){

			double weight = bitmaps_weight[ct];

			BitSet signature = bitmaps_signature[ct];
			BitSet mask = bitmaps_mask[ct];

			// clause: c1 v !c2 v c3   (there are other atoms c4 and c5)
			//		=> 10100 as signature, 11100 as mask
			// given a world T
			// sat = \exists 1 in [ (T ^ 10100) v !(T v 10100) ] ^ 11100

			BitSet TandSIG = (BitSet) world.clone();
			TandSIG.and(signature);

			BitSet notTorSIG = (BitSet) world.clone();
			notTorSIG.or(signature);

			TandSIG.and(mask);
			BitSet tocheck = (BitSet) mask.clone();

			tocheck.andNot(notTorSIG);
			tocheck.or(TandSIG);

			if(tocheck.isEmpty()){
				if(weight > 0){
					rs += weight;
				}
			}else{
				if(weight < 0){
					rs += -weight;
				}
			}

		}
		return rs;
	}

	public double getFlipDelta(BitSet world, int atomID){

		double delta = 0;
		for(int clause : this.localAtom2Clause.get(atomID)){
			delta -= -this.getCostOfClause(world, clause);
		}

		world.flip(atomID);

		for(int clause : this.localAtom2Clause.get(atomID)){
			delta += -this.getCostOfClause(world, clause);
		}

		world.flip(atomID);

		return delta;
	}

	public double getCostOfClause(BitSet world, int clauseID){
		double rs = 0;
		int ct = clauseID;

		double weight = bitmaps_weight[ct];

		BitSet signature = bitmaps_signature[ct];
		BitSet mask = bitmaps_mask[ct];

		// clause: c1 v !c2 v c3   (there are other atoms c4 and c5)
		//		=> 10100 as signature, 11100 as mask
		// given a world T
		// sat = \exists 1 in [ (T ^ 10100) v !(T v 10100) ] ^ 11100

		BitSet TandSIG = (BitSet) world.clone();
		TandSIG.and(signature);

		BitSet notTorSIG = (BitSet) world.clone();
		notTorSIG.or(signature);

		TandSIG.and(mask);
		BitSet tocheck = (BitSet) mask.clone();

		tocheck.andNot(notTorSIG);
		tocheck.or(TandSIG);

		if(tocheck.isEmpty()){
			if(weight > 0){
				rs += weight;
			}
		}else{
			if(weight < 0){
				rs += -weight;
			}
		}

		return rs;
	}

	public Integer[] getClauseTallies(BitSet world){

		Integer[] rs = new Integer[clauses.size()];

		for(int ct=0;ct<bitmaps_weight.length;ct++){

			rs[ct] = 0;

			double weight = bitmaps_weight[ct];

			BitSet signature = bitmaps_signature[ct];
			BitSet mask = bitmaps_mask[ct];

			// clause: c1 v !c2 v c3   (there are other atoms c4 and c5)
			//		=> 10100 as signature, 11100 as mask
			// given a world T
			// sat = \exists 1 in [ (T ^ 10100) v !(T v 10100) ] ^ 11100

			BitSet TandSIG = (BitSet) world.clone();
			TandSIG.and(signature);

			BitSet notTorSIG = (BitSet) world.clone();
			notTorSIG.or(signature);

			TandSIG.and(mask);
			BitSet tocheck = (BitSet) mask.clone();

			tocheck.andNot(notTorSIG);
			tocheck.or(TandSIG);

			// TODO: change to faster implementation of tally
			if(tocheck.isEmpty()){
				// tocheck == 000000... <--- false
				if(weight > 0){
					rs[ct] ++;
				}

			}else{
				// tocheck != 000000... <--- true
				if(weight < 0){
					rs[ct] ++;
				}
			}
		}

		return rs;
	}

	public Integer[] getClauseSat(BitSet world){

		Integer[] rs = new Integer[clauses.size()];

		for(int ct=0;ct<bitmaps_weight.length;ct++){

			rs[ct] = 0;

			double weight = bitmaps_weight[ct];

			BitSet signature = bitmaps_signature[ct];
			BitSet mask = bitmaps_mask[ct];

			// clause: c1 v !c2 v c3   (there are other atoms c4 and c5)
			//		=> 10100 as signature, 11100 as mask
			// given a world T
			// sat = \exists 1 in [ (T ^ 10100) v !(T v 10100) ] ^ 11100

			BitSet TandSIG = (BitSet) world.clone();
			TandSIG.and(signature);

			BitSet notTorSIG = (BitSet) world.clone();
			notTorSIG.or(signature);

			TandSIG.and(mask);
			BitSet tocheck = (BitSet) mask.clone();

			tocheck.andNot(notTorSIG);
			tocheck.or(TandSIG);

			// TODO: change to faster implementation of tally
			if(tocheck.isEmpty()){
				// tocheck == 000000... <--- false
				if(weight < 0){
					rs[ct] ++;
				}

			}else{
				// tocheck != 000000... <--- true
				if(weight > 0){
					rs[ct] ++;
				}
			}
		}

		return rs;
	}

	public String getWeightArray(){
		String rs = "{";
		for(int i=0;i<bitmaps_weight.length;i++){
			if(i == 0){
				rs = rs + bitmaps_weight[i];
			}else{
				rs = rs + "," + bitmaps_weight[i];
			}
		}
		rs = rs + "}";
		return rs;
	}

	public String getClauseArray(){
		String rs = "{";
		rs = rs + clausesSignature;
		rs = rs + "}";
		return rs;
	}

	public String getQueryArray(){
		String rs = "{";

		for(Integer i : this.globalAtom.keySet()){
			GAtom global = this.globalAtom.get(i);
			if(global.isquery){
				if(rs.equals("{")){
					rs = rs + i;
				}else{
					rs = rs + ", " + i;
				}
			}
		}

		rs = rs + "}";
		return rs;
	}

	public class myDouble{

		public double value = Double.NEGATIVE_INFINITY;

		public double logAdd(double logX, double logY) {

			if (logY > logX) {
				double temp = logX;
				logX = logY;
				logY = temp;
			}

			if (logX == Double.NEGATIVE_INFINITY) {
				return logX;
			}

			double negDiff = logY - logX;
			if (negDiff < -200) {
				return logX;
			}

			return logX + java.lang.Math.log(1.0 + java.lang.Math.exp(negDiff)); 
		}

		public void tallylog(double plus){
			value = logAdd(value, plus);
		}

	}

	public double MLE_populateTaskToDBFast(int myID, int nSamples, int nMachines){
		/*
		this.compile();

		for(int machine = 0; machine < nMachines; machine ++){
			String taskID = DigestUtils.md5Hex("" + myID + "---" + machine);

			String pid = "" + myID;
			String mid = "" + machine;

			String weight = this.getWeightArray();
			String clause = this.getClauseArray();
			String query  = this.getQueryArray();
			String nsample = "" + (nSamples/nMachines + 1);
			String nvariable = "" + (this.globalAtom.size());

			System.out.println(taskID + "\t" + pid + "\t" + mid + "\t" + weight + "\t" + clause + "\t" + query + "\t" + nsample + "\t" + nvariable);


		}

		return 0;
		 */

		return 0;
	}

	public double logAdd(double logX, double logY) {

		if (logY > logX) {
			double temp = logX;
			logX = logY;
			logY = temp;
		}

		if (logX == Double.NEGATIVE_INFINITY) {
			return logX;
		}

		double negDiff = logY - logX;
		if (negDiff < -200) {
			return logX;
		}

		return logX + java.lang.Math.log(1.0 + java.lang.Math.exp(negDiff)); 
	}

	public HashMap<String, Double> MLE_getGradientUpdate(HashMap<String, Double> currentWeight, double mu, double alpha){

		ExceptionMan.die("Why are you still using the slower version? :-)");
		return null;

		//System.out.println("graident 1");
		/*
		HashMap<String, Double> rs = new HashMap<String, Double>();

		HashMap<String, myDouble> tally_small = new HashMap<String, myDouble>();
		HashMap<String, myDouble> tally_large = new HashMap<String, myDouble>();
		Double smallZ = Double.NEGATIVE_INFINITY;
		Double largeZ = Double.NEGATIVE_INFINITY;

		for(String c : currentWeight.keySet()){
			tally_small.put(c, new myDouble());
			tally_large.put(c, new myDouble());
		}

		//System.out.println("graident 2");
		int nbatch = 1;

		for(int batch=0;batch<nbatch;batch ++){

			//System.out.print(".");
			BitSet bitmap_smallsample = new BitSet();
			BitSet bitmap_largesample = new BitSet();

			for(Integer atomid: globalAtom.keySet()){

				GAtom atom = globalAtom.get(atomid);

				if(atom.isquery){
					if(atom.truth){
						bitmap_smallsample.set(atomid);
					}
					if(Math.random() > 0.5){
						bitmap_largesample.set(atomid);
					}
				}else{

					if(Math.random() > 0.5){
						bitmap_smallsample.set(atomid);
					}

					if(Math.random() > 0.5){
						bitmap_largesample.set(atomid);
					}
				}

			}

			HashMap<String, Double> tally_small_meta = getClauseTallies(bitmap_smallsample);
			HashMap<String, Double> tally_large_meta = getClauseTallies(bitmap_largesample);

			double c_small = this.getCost(bitmap_smallsample);
			double c_large = this.getCost(bitmap_largesample);


			bitmap_smallsample = new BitSet();
			bitmap_largesample = new BitSet();

			for(Integer atomid: globalAtom.keySet()){

				GAtom atom = globalAtom.get(atomid);

				if(atom.isquery){
					if(atom.truth){
						bitmap_smallsample.set(atomid);
					}
					if(Math.random() > 0.5){
						bitmap_largesample.set(atomid);
					}
				}else{

					if(Math.random() > 0.5){
						bitmap_smallsample.set(atomid);
					}

					if(Math.random() > 0.5){
						bitmap_largesample.set(atomid);
					}
				}

			}

			double c_smallz = this.getCost(bitmap_smallsample);
			smallZ = logAdd(-c_smallz, smallZ);

			double c_largez = this.getCost(bitmap_largesample);
			largeZ = logAdd(-c_largez, largeZ);

			for(String c : tally_small_meta.keySet()){
				tally_small.get(c).tallylog( -c_small + Math.log(tally_small_meta.get(c)));
				//System.out.println("~~~");
				//System.out.println(-c_small);
				//System.out.println(currentWeight);
				//System.out.println(tally_small_meta.get(c));
				//System.out.println("###");
			}

			for(String c : tally_large_meta.keySet()){
				tally_large.get(c).tallylog( -c_large + Math.log(tally_large_meta.get(c)));
			}

		}

		//TODO: change to log base

		for(String ffcid : currentWeight.keySet()){

			double delta = 0;
			double m1 = 0;
			double m2 = 0;

			if(tally_small.containsKey(ffcid)){
				//m1 = tally_small.get(ffcid) * Math.exp(-c_small - logsum);
				m1 = Math.exp(tally_small.get(ffcid).value - smallZ);
				//m1 = tally_small.get(ffcid);
			}

			if(tally_large.containsKey(ffcid)){
				//m2 = tally_large.get(ffcid) * Math.exp(-c_large - logsum);
				m2 = Math.exp(tally_large.get(ffcid).value - largeZ);
				//System.out.println("tally_large: " + tally_large.get(ffcid).value);
				//System.out.println("largeZ: " + largeZ);
				//System.out.println("m2: " + m2);
				System.out.println("weight: " + currentWeight);
			}

			//System.out.println("smallZ = " + smallZ + ", largeZ = " + largeZ + 
			//		"; smallTally = " + tally_small.get(ffcid).value + 
			//		", largeTally = " + tally_large.get(ffcid).value);
			//System.out.println("m1 = " + m1 + ", m2 = " + m2);

			System.out.println(tally_small + "\t" + tally_large + "\t" + smallZ + "\t" + smallZ + "\t" + m1 + "\t" + m2);

			if(m2 == Double.NEGATIVE_INFINITY || m2== Double.POSITIVE_INFINITY || m1 == Double.NEGATIVE_INFINITY || m2 == Double.POSITIVE_INFINITY){
				delta = 0 ;
			}else{

				if(Math.abs(alpha * (m2-m1)) > 0.001){
					delta += 0.1/alpha;
				}else{
					delta += (m2 - m1);
				}	
			}

			rs.put(ffcid, currentWeight.get(ffcid) + alpha * delta);

		}

		//TODO: change the flushing of weight somewhere else
		for(int ct=0;ct<bitmaps_weight.length;ct++){

			GClause gc = clauses.get(ct);

			bitmaps_weight[ct] = 0;

			for(String ffcid : gc.ffcid){

				if(ffcid.startsWith("-")){
					bitmaps_weight[ct] -= currentWeight.get(ffcid);
				}else{
					bitmaps_weight[ct] += currentWeight.get(ffcid);
				}

			}

			gc.weight = bitmaps_weight[ct];


		}
		return rs;
		 */
	}


	/*
	public double MLE_gibbsSampler(int nSamples){

		this.compile();

	}
	 */


	public double MLE_naiveSampler(int nSamples){

		this.compile();

		ArrayList<MLEWorker> samplers = new ArrayList<MLEWorker>();

		int metaSample = (int)Math.ceil(1.0*nSamples / Config.innerPara);

		for(int i=0;i<Config.innerPara;i++){

			MLEWorkerInstance sampler = null;


			if(Config.mle_use_mcsat_sampling){

				sampler = new MLEWorkerInstance(this, metaSample,
						SampleAlgorithm_MCSAT.class, null);

			}else if(Config.mle_use_gibbs_sampling){

				sampler = new MLEWorkerInstance(this, metaSample,
						SampleAlgorithm_MetropolisHastingsSampling.class, null);

			}else if(Config.mle_use_serialmix_sampling){

				sampler = new MLEWorkerInstance(this, metaSample, 
						SampleAlgorithm_SerialMixture.class, null);

			}else{

				sampler = new MLEWorkerInstance(this, metaSample, 
						SampleAlgorithm_NaiveSampling.class, null);

			}

			samplers.add(sampler);
			sampler.start();

		}

		try {
			for(int i=0;i<Config.innerPara;i++){
				samplers.get(i).join();
			}
		} catch (InterruptedException e) {
			ExceptionMan.die(e.getMessage());
		}

		MLEWorld allworld = new MLEWorld(empty);

		HashMap<BitSet, MLEWorld> worlds = new HashMap<BitSet, MLEWorld>();
		for(int i=0;i<Config.innerPara;i++){
			// TODO: may need some smarter top-k algorithm
			ArrayList<MLEWorld> topk = samplers.get(i).getTopK(-1);
			for(MLEWorld world : topk){
				if(worlds.containsKey(world.bitmap)){
					worlds.get(world.bitmap).tallyLogCost(world.logCost);
					worlds.get(world.bitmap).tallyFreq(world.freq);
				}else{
					worlds.put(world.bitmap, world);
				}
				allworld.tallyFreq(world.freq);
				allworld.tallyLogCost(world.logCost);
			}
		}

		ArrayList<MLEWorld> mlers = new ArrayList<MLEWorld>();
		mlers.addAll(worlds.values());

		if(Config.mle_use_gibbs_sampling || Config.mle_use_mcsat_sampling){
			Collections.sort(mlers, new Comparator<MLEWorld>(){
				@Override
				public int compare(MLEWorld o1, MLEWorld o2) {
					if(o1.freq > o2.freq){
						return -1;
					}else if (o1.freq == o2.freq){
						return 0;
					}else{
						return 1;
					}
				}
			});
		}else{
			Collections.sort(mlers, new Comparator<MLEWorld>(){
				@Override
				public int compare(MLEWorld o1, MLEWorld o2) {
					if(o1.logCost > o2.logCost){
						return -1;
					}else if (o1.logCost == o2.logCost){
						return 0;
					}else{
						return 1;
					}
				}
			});
		}

		if(mlers.size() > 0){
			MLEWorld top1 = mlers.get(0);

			for(Integer natom : this.coreAtoms){
				this.atoms.get(natom).truth = false;
			}

			if(Config.mle_use_gibbs_sampling || Config.mle_use_mcsat_sampling){
				for (int pos = top1.bitmap.nextSetBit(0); pos >= 0; pos = top1.bitmap.nextSetBit(pos+1)) {
					this.globalAtom.get(pos).truth = true;
				}

				for(GAtom atom : this.atoms.values()){
					atom.prob = (float) (atom.tallyTrueFreq / atom.tallyFreq);
				}
			}else{

				for (int pos = top1.bitmap.nextSetBit(0); pos >= 0; pos = top1.bitmap.nextSetBit(pos+1)) {
					this.globalAtom.get(pos).truth = true;
				}

				for(GAtom atom : this.atoms.values()){
					atom.prob = (float) Math.exp(atom.tallyTrueLogWeight - atom.tallyLogWeight);
				}

			}

			//System.out.println(">>> Top Freq = " + top1.freq);
			return Math.exp(top1.logCost - allworld.logCost);
		}

		return 1;

	}

	private double costPadding = 0;

	public void updateSingletonClauses(HashMap<Integer, Double> deltas, boolean inv) {
		if (singletons == null) {
			singletons = new HashMap<Integer, GClause>();
			/*
			for (GClause gc : clauses) {
				if (gc.lits.length == 1) {
					singletons.put(gc.lits[0], gc);
				}
			}
			 */
		}

		int newones = 0;
		for (int a : deltas.keySet()) {
			if (!coreAtoms.contains(a)) continue;
			double w = deltas.get(a);
			if (inv) w = -w;
			GClause gc = singletons.get(a);
			if (gc == null) {
				//System.out.println("@@@ " + a + " : " + w);
				gc = new GClause();
				gc.lits = new int[] {a};
				gc.weight = w;
				singletons.put(a, gc);
				clauses.add(gc);
				factors.put(gc, new FactorState(gc));
				ArrayList<GClause> ll = fidx.get(a);
				if (ll == null) {
					ll = new ArrayList<GClause>();
					fidx.put(a, ll);
				}
				ll.add(gc);
				
				newones ++;
				ArrayList<GClause> plist = adj.get(a);
				if (plist == null) {
					plist = new ArrayList<GClause>();
					adj.put(a, plist);
				}
				plist.add(gc);
			} else {
				gc.weight += w;
				//UIMan.verbose(1, "" + a + " : " + w);
			}
		}
		costPadding = 0;
		for (GClause gc : singletons.values()) {
			if (gc.weight > 0) costPadding += Math.abs(gc.weight);
		}
		if (newones > 0) {
			//UIMan.verbose(1, "@@@ New singleton clauses = " + newones);
		}
	}


	/**
	 * Array of unsatisfied GClauses under current atoms' truth setting.
	 */
	protected HashArray<GClause> unsat = new HashArray<GClause>();

	/**
	 * Index from Literal ID to GClause.
	 */
	public HashMap<Integer, ArrayList<GClause>> adj = new HashMap<Integer, ArrayList<GClause>>();

	int numCriticalNodesLocal = 0;

	int numClausesInCut = 0;

	double weightClausesInCut = 0;

	/**
	 * Atoms that have been flipped since last saving to low.
	 */
	protected HashSet<Integer> dirtyAtoms = new HashSet<Integer>();

	/**
	 * The total cost of this MRF under current atoms' truth setting.
	 */
	protected double totalCost = Double.MAX_VALUE;

	public double getCost(){
		return totalCost;
	}

	/**
	 * Lowest cost ever seen.
	 */
	public double lowCost = Double.MAX_VALUE;

	/**
	 * Number of GClauses that is selected, and therefore must be
	 * satisfied by next SampleSAT invocation of MCSAT.
	 */
	protected int totalAlive = 0;

	/**
	 * The flag indicating whether MCSAT is running WalkSAT 
	 * or SampleSAT.
	 */
	public boolean sampleSatMode = false;

	int partID = 0;
	public long inferOps = 0;

	/**
	 * The MLN object.
	 */
	private MarkovLogicNetwork mln;


	public MarkovLogicNetwork getMLN(){
		return mln;
	}

	/**
	 * Reset low-cost to infinity.
	 */
	public void invalidateLowCost(){
		lowCost = Double.MAX_VALUE;
	}

	/**
	 * For research experiments!
	 * Split the MRF into multiple pieces by agglomerative clustering.
	 * Each piece contains up to 2/np of the total atoms.
	 * 
	 * @param np number of pieces
	 * @return the pieces, each as an individual MRF
	 */
	@SuppressWarnings("unused")
	private ArrayList<MRF> split(int np){
		Random r = new Random();
		ArrayList<MRF> pieces = new ArrayList<MRF>();
		ArrayList<Integer> as = new ArrayList<Integer>(atoms.keySet());
		HashSet<Integer> danglings = new HashSet<Integer>(atoms.keySet());
		Collections.shuffle(as);
		int imb = 1;// + r.nextInt(3);
		int maxs = (int) (atoms.size() * (1.0/np + r.nextDouble()*(1.0/np)));
		HashMap<Integer, MRF> amap = new HashMap<Integer, MRF>();
		int cur = 0;
		// assign seed nodes
		for(int i=0; i<np; i++){
			MRF m = new MRF(mln, i, atoms);
			m.ownsAllAtoms = false;
			pieces.add(m);
			m.numCriticalNodesLocal = 0;
			if(i==0){
				for(int k=imb; k>0; k--){
					int aid = as.get(cur++);
					GAtom a = atoms.get(aid);
					while(!a.critical()){
						aid = as.get(cur++);
						a = atoms.get(aid);
					}
					if(a.critical()){
						m.numCriticalNodesLocal ++;
					}
					amap.put(aid, m);
					m.addAtom(aid);
					danglings.remove(aid);
				}
			}else{
				int aid = as.get(cur++);
				GAtom a = atoms.get(aid);
				while(!a.critical()){
					aid = as.get(cur++);
					a = atoms.get(aid);
				}
				if(a.critical()){
					m.numCriticalNodesLocal ++;
				}
				amap.put(aid, m);
				m.addAtom(aid);
				danglings.remove(aid);
			}
		}
		for(int aid : atoms.keySet()){
			GAtom a = atoms.get(aid);
			a.cut = false;
		}

		// assign remaining nodes
		while(!danglings.isEmpty()){
			Iterator<Integer> it = danglings.iterator();
			while(it.hasNext()){
				int aid = it.next();
				HashSet<Integer> ns = getAtomNeighbors(aid);
				ArrayList<Integer> opts = new ArrayList<Integer>();
				for(int a : ns){
					if(amap.get(a) != null){
						opts.add(a);
					}
				}
				MRF m = pieces.get(r.nextInt(np));
				if(!opts.isEmpty()){
					m = amap.get(opts.get(r.nextInt(opts.size())));
					if(m.getCoreAtoms().size() > maxs){
						int ot = r.nextInt(np);
						while(ot == pieces.indexOf(m)){
							ot = r.nextInt(np);
						}
						m = pieces.get(ot);
					}
				}else{
					continue;
				}
				GAtom a = atoms.get(aid);
				if(a.critical()){
					m.numCriticalNodesLocal ++;
				}
				amap.put(aid, m);
				m.addAtom(aid);
				it.remove();
			}
		}

		double gcSize = 0;
		double gcWeight = 0;
		for(GClause gc : clauses){
			int aid = Math.abs(gc.lits[r.nextInt(gc.lits.length)]);
			MRF m = amap.get(aid);
			m.clauses.add(gc);
			gcSize ++;
			gcWeight += Math.abs(gc.weight);
		}
		ArrayList<Double> numLCs = new ArrayList<Double>();
		double cutSize = 0;
		double cutWeight = 0;
		for(MRF m : pieces){
			m.buildIndices();
			numLCs.add((double)m.numCriticalNodesLocal);
			cutSize += m.numClausesInCut;
			cutWeight += m.weightClausesInCut;
			DebugMan.log(m.numCriticalNodesLocal + ", ");
		}
		double gaSize = 0;
		double gaCritical = 0;
		double atomsCriticalCut = 0;
		double atomsCut = 0;
		for(GAtom a : atoms.values()){
			gaSize ++;
			if(a.critical()){
				gaCritical++;
			}
			if(a.cut){
				atomsCut++;
				if(a.critical()){
					atomsCriticalCut++;
				}
			}
		}

		DebugMan.log("np, " + np + ", ");
		double imbb = Collections.max(numLCs) / this.numCriticalNodesLocal;
		DebugMan.log("maxpart, " + UIMan.comma(imbb) + ", ");
		double atomsCutPortion = atomsCut / gaSize;
		DebugMan.log("atomsCut, " + UIMan.comma(atomsCutPortion) + ", ");
		double atomsCriticalCutPortion = atomsCriticalCut / gaCritical;
		DebugMan.log("atomsCriticalCut, " + UIMan.comma(atomsCriticalCutPortion) + ", ");
		double clausesCutPortion = cutSize / gcSize;
		DebugMan.log("clausesCut, " + UIMan.comma(clausesCutPortion) + ", ");
		double clausesWtCutPortion = cutWeight / gcWeight;
		DebugMan.log("clausesWtCut, " + UIMan.comma(clausesWtCutPortion) + ", ");

		return pieces;
	}

	/**
	 * For research experiments!
	 * Get all neighboring atoms of one atom.
	 * @param aid id of the core atom
	 * @return id of neighbors
	 */
	private HashSet<Integer> getAtomNeighbors(int aid){
		HashSet<Integer> ns = new HashSet<Integer>();
		for(GClause gc : adj.get(aid)){
			for(int lit : gc.lits){
				ns.add(Math.abs(lit));
			}
		}
		for(GClause gc : adj.get(-aid)){
			for(int lit : gc.lits){
				ns.add(Math.abs(lit));
			}
		}
		return ns;
	}


	/**
	 * Discard all data structures, in hope of facilitating faster GC.
	 */
	public void discard() {
		atoms = null;
		getCoreAtoms().clear();
		clauses.clear();
		unsat.clear();
		adj.clear();
		clauses = null;
		coreAtoms = null;
		states = null;
		factors = null;
		fidx.clear();
		nodeSequence.clear();
		processed.clear();
		inQ.clear();
		fidx = null;
		nodeSequence = null;
		processed = null;
		inQ = null;
		singletons = null;
	}

	/**
	 * Add an atom into this MRF.
	 * @param aid id of the atom
	 */
	public void addAtom(int aid){
		getCoreAtoms().add(aid);
	}

	/**
	 * Default constructor.
	 * Does not really do anything.
	 */
	public MRF(MarkovLogicNetwork mln){
		this.mln = mln;
	}

	/**
	 * 
	 * @param partID id of this MRF
	 * @param gatoms ground atoms
	 */
	public MRF(MarkovLogicNetwork mln, int partID, HashMap<Integer, GAtom> gatoms){
		this.partID = partID;
		atoms = gatoms;
	}

	/**
	 * Test if a given atom is "owned" by this MRF.
	 * An atom may not belong to this MRF if this MRF represents
	 * a partition of a component that has multiple partitions.
	 * 
	 * @param aid id of the atom
	 * 
	 */
	protected boolean ownsAtom(int aid){
		return ownsAllAtoms || getCoreAtoms().contains(aid);
	}

	protected boolean ownsAtom(int aid, HashSet<Integer> notChange){

		if(notChange != null && notChange.contains(aid)){
			return false;
		}

		return ownsAllAtoms || getCoreAtoms().contains(aid);

	}

	/**
	 * If current truths have the lowest cost, save them.
	 * @param cost the current cost
	 */
	protected void saveLowTruth(double cost){
		if(!(cost < lowCost || (cost < 0.0001 && sampleSatMode))) return;
		if(cost < lowCost) lowCost = cost;
		if(dirtyAtoms.size() > 0){ // incremental dump
			for(int aid : dirtyAtoms){
				GAtom ga = atoms.get(aid);
				ga.lowTruth = ga.truth;
			}
			dirtyAtoms.clear();
		}else{ // force flushing
			if(ownsAllAtoms){
				for(GAtom n : atoms.values()){
					n.lowTruth = n.truth;
				}
			}else{
				for(int aid : getCoreAtoms()){
					GAtom n = atoms.get(aid);
					n.lowTruth = n.truth;
				}
			}
		}
	}


	private void saveTruthAsLow(){
		if(ownsAllAtoms){
			for(GAtom n : atoms.values()){
				n.lowTruth = n.truth;
			}
		}else{
			for(int aid : getCoreAtoms()){
				GAtom n = atoms.get(aid);
				n.lowTruth = n.truth;
			}
		}
	}


	/**
	 * Check if a given literal is true under current truth assignment.
	 * @param lit the literal represented as an integer
	 * 
	 */
	protected boolean isTrueLit(int lit){
		return (lit > 0 && atoms.get(lit).truth) 
				|| (lit < 0 && !atoms.get(-lit).truth);
	}

	/**
	 * Test if a clause is always true no matter how we flip flippable atoms.
	 * @param gc the clause
	 * 
	 */
	protected boolean isAlwaysTrue(GClause gc){
		int fixed = 0;
		for(int lit : gc.lits){
			if(!ownsAtom(Math.abs(lit))){
				if(isTrueLit(lit)){
					return true;
				}
				fixed ++;
			}
		}
		return fixed == gc.lits.length;
	}

	/**
	 * Fix the truth value of an atom.
	 * @param aid id of the atom
	 * @param t truth value to be fixed
	 */
	protected void fixAtom(int aid, boolean t){
		GAtom a = atoms.get(aid);
		a.truth = t;
		a.fixed = true;
	}



	/**
	 * Retain a subset of currently satisfied clauses, according
	 * to the sampling method of MC-SAT.
	 * 
	 * @return the number of retained clauses
	 */
	protected int retainSomeGoodClauses(){
		int numGood = 0;
		totalAlive = 0;
		for(GClause c : clauses){
			if(c.cost() == 0) numGood++;
			if(c.selectMCSAT()){
				c.dead = false;
				++ totalAlive;
			}else{
				c.dead = true;
			}
		}
		if(!Config.learning_mode)
			UIMan.verbose(2, "    Retained #clauses = " + UIMan.comma(totalAlive) + 
					" out of " + UIMan.comma(numGood) + " non-violated clauses (" + 
					UIMan.comma(clauses.size()) + " in total)");
		return totalAlive;
	}


	/**
	 * Unfix all atoms.
	 */
	protected void unfixAllAtoms(){
		for(GAtom a : atoms.values()){
			a.fixed = false;
		}
	}


	/**
	 * Assign the recorded low-cost truth values to current truth values.
	 */
	public void restoreLowTruth(){
		if(ownsAllAtoms){
			for(GAtom n : atoms.values()){
				n.truth = n.lowTruth;
			}
		}else{
			for(int aid : getCoreAtoms()){
				GAtom n = atoms.get(aid);
				n.truth = n.lowTruth;
			}
		}
	}

	/**
	 * Reset all clauses to be alive.
	 */
	public void enableAllClauses(){
		totalAlive = clauses.size();
		for(GClause c : clauses){
			c.dead = false;
		}
	}

	/**
	 * Build literal-->clauses index.
	 * Used by WalkSAT.
	 */
	public void buildIndices(){
		if(!adj.isEmpty()) return;
		adj.clear();
		for(GClause f : clauses){
			boolean isCut = false;
			for(int lit : f.lits){
				ArrayList<GClause> plist = adj.get(lit);
				if(plist == null){
					plist = new ArrayList<GClause>();
					adj.put(lit, plist);
				}
				plist.add(f);
				if(!ownsAllAtoms && !getCoreAtoms().contains(Math.abs(lit))){
					isCut = true;
				}
				if(Config.checkNumCriticalNodes){
					GAtom n = atoms.get(Math.abs(lit));
					if((lit > 0) == (f.weight > 0)){
						n.markWannaBeTrue();
					}else{
						n.markWannaBeFalse();
					}
				}
			}
			if(isCut){
				numClausesInCut++;
				weightClausesInCut += Math.abs(f.weight);
				for(int lit : f.lits){
					atoms.get(Math.abs(lit)).cut = true;
				}
			}
		}
	}

	private Random rand = new Random();



	/**
	 * Coin flipping.
	 * @param p probability of returning true
	 * 
	 */
	protected boolean testChance(double p){
		return rand.nextDouble() < p;
	}

	@SuppressWarnings("unused")
	private void testKeyConstraints(){

		HashMap<Integer, myInt> counter = new HashMap<Integer, myInt>();

		for(GAtom g : atoms.values()){

			Integer key = keyBlock.gatom2key.get(g);

			if(key == null){
				continue;
			}

			if(!counter.containsKey(key)){
				counter.put(key, new myInt(0));
			}
			if(g.truth == true){
				counter.get(key).addOne();
			}
		}

		for(Integer key : counter.keySet()){
			if(counter.get(key).value >= 2){
				System.err.print("DUPLICATION!!!");
			}
		}

	}

	private class Message {
		int atomID = -1;
		double posVal = 0;
		double negVal = 0;
		public Message(int a) {
			atomID = a;
		}
	}

	private class NodeState {
		int atomID = -1;
		double posVal = 0;
		double negVal = 0;
		private boolean summed = false;
		Boolean truth = null;

		HashSet<GClause> sentTo = new HashSet<GClause>();
		WeakHashMap<GClause, Message> messages = new WeakHashMap<GClause, Message>();
		WeakHashMap<GClause, Message> sentMessages = new WeakHashMap<GClause, Message>();

		public void absorbFactorMessage(GClause gc, Message ns) {
			if (atomID != ns.atomID) return;
			messages.put(gc, ns);

			if (debugTree) {
				System.out.println("MSG Atom " + atomID + " <= Clause " + 
						gc.id + " : " + ns.negVal + "; " + ns.posVal);
			}

			// invalidate sums
			if (summed) {
				summed = false;
				posVal = negVal = 0;
			}
		}

		public void reset() {
			summed = false;
			posVal = negVal = 0;
			messages.clear();
			sentTo.clear();
			truth = null;
		}
		
		public void sumMessages() {
			if (!summed) {
				posVal = negVal = 0;
				for (GClause c : messages.keySet()) {
					Message msg = messages.get(c);
					posVal += msg.posVal;
					negVal += msg.negVal;
				}
				summed = true;
			}
		}

		public Message genMsgForClause(GClause gc) {
			sumMessages();
			Message ns = sentMessages.get(gc);
			if (ns == null) {
				ns = new Message(atomID);
				sentMessages.put(gc, ns);
			}
			ns.posVal = posVal;
			ns.negVal = negVal;
			Message msg = messages.get(gc);
			if (msg != null) {
				ns.posVal -= msg.posVal;
				ns.negVal -= msg.negVal;
			}
			sentTo.add(gc);
			return ns;
		}


		public void absorbBit(boolean val) {
			if (truth != null) ExceptionMan.die("BAD MSG " + atomID);
			truth = val;
			if (debugTree) {
				System.out.println("MSG Atom " + atomID + " <= " + val);
			}
		}

		public boolean getOptBit() {
			if (truth == null) {
				sumMessages();
				truth = (posVal < negVal);
				if (debugTree) {
					System.out.println("MSG Atom " + atomID + " * " + truth);
				}
			}
			return truth;
		}

		public NodeState(int atomID) {
			this.atomID = atomID;
		}
	}

	private boolean debugTree = false;

	private class FactorState {
		GClause clause = null;

		HashSet<Integer> posAtoms = new HashSet<Integer>();
		HashSet<Integer> negAtoms = new HashSet<Integer>();
		HashMap<Integer, Message> messages = new HashMap<Integer, Message>();
		HashMap<Integer, Message> sentMessages = new HashMap<Integer, Message>();
		HashSet<Integer> openAtoms = new HashSet<Integer>();

		HashSet<Integer> receivedFrom = new HashSet<Integer>();
		HashSet<Integer> sentTo = new HashSet<Integer>();
		HashMap<Integer, Boolean> optStates = new HashMap<Integer, Boolean>();
		boolean optimized = false;


		public void reset() {
			optimized = false;
			messages.clear();
			sentTo.clear();
			receivedFrom.clear();
			optStates.clear();
			posAtoms.clear();
			negAtoms.clear();
			openAtoms.clear();
			for (int lit : clause.lits) {
				if (lit > 0) {
					posAtoms.add(lit);
				} else {
					negAtoms.add(-lit);
				}
			}
		}
		
		
		public void absorbNodeMessage(Message ns) {
			messages.put(ns.atomID, ns);
			receivedFrom.add(ns.atomID);
			optimized = false;
			if (debugTree) {
				System.out.println("MSG Clau " + clause.id + " <= Atom " + 
						ns.atomID + " : " + ns.negVal + "; " + ns.posVal);	
			}
		}

		public void absorbBit(int atomID, boolean val) {
			optStates.put(atomID, val);

			if (debugTree) {
				System.out.println("MSG Clau " + clause.id + " <= Atom " + 
						atomID + " : " + val);
			}
		}

		public Boolean getOptStateForAtom(int atomID) {
			if (!optimized) {
				openAtoms.clear();
				openAtoms.addAll(posAtoms);
				openAtoms.addAll(negAtoms);
				boolean sat = false;
				if (debugTree) System.out.println(clause);
				for (int a : optStates.keySet()) {
					openAtoms.remove(a);
					if (optStates.get(a).equals(posAtoms.contains(a))) {
						sat = true;
					}
				}
				if (openAtoms.isEmpty()) return optStates.get(atomID);
				double costToMakeFalse = 0;
				double costToMakeTrue = 0;
				double minBumpToMakeTrue = Double.MAX_VALUE;
				int whoToBump = -1;
				for (int a : openAtoms) {
					Message msg = messages.get(a);
					costToMakeTrue += Math.min(msg.negVal, msg.posVal);
					if ((posAtoms.contains(a) && msg.negVal > msg.posVal) ||
							(negAtoms.contains(a) && msg.negVal <= msg.posVal) ||
							sat){ 
						// lower-cost truth and satisfying truth match
						// no need to make bump to satisfy formula
						minBumpToMakeTrue = 0;
						whoToBump = -1;
					} else {
						// need to make a bump on this one to make formula true
						if (Math.abs(msg.negVal-msg.posVal) < minBumpToMakeTrue) {
							minBumpToMakeTrue = Math.abs(msg.negVal-msg.posVal);
							whoToBump = a;
						}
					}
					if (posAtoms.contains(a)) {
						costToMakeFalse = msg.negVal;
					} else {
						costToMakeFalse = msg.posVal;
					}
				}
				costToMakeTrue += minBumpToMakeTrue;
				if (clause.weight > 0 && !sat) costToMakeFalse += Math.abs(clause.weight);
				if (clause.weight < 0) costToMakeTrue += Math.abs(clause.weight);
				
				if (sat) costToMakeFalse = Double.MAX_VALUE;
				
				/*
				System.out.println("sat = " + sat);
				System.out.println("bump = " + minBumpToMakeTrue);
				System.out.println("whobump = " + whoToBump);
				System.out.println("ct = " + costToMakeTrue + " ; cf = " + costToMakeFalse);
				*/
				
				if (costToMakeTrue < costToMakeFalse) {
					for (int a : openAtoms) {
						Boolean val = null;
						Message msg = messages.get(a);
						if (msg.posVal >= msg.negVal) {
							val = false;
						} else {
							val = true;
						}
						if (whoToBump == a) val = !val;
						optStates.put(a, val);
					}
				} else {
					for (int a : openAtoms) {
						Boolean val = null;
						if (posAtoms.contains(a)) {
							val = false;
						} else {
							val = true;
						}
						optStates.put(a, val);
					}
				}

				optimized = true;
			}
			return optStates.get(atomID);
		}

		public Message genMsgForAtom(int atomID) {
			// value for the case when this literal is true
			double valT = 0;

			for (int a : messages.keySet()) {
				if (a == atomID) continue;
				Message msg = messages.get(a);
				valT += Math.min(msg.negVal, msg.posVal);
			}

			if (clause.weight < 0) valT += Math.abs(clause.weight);

			// value for the case when this literal is false
			double valF = 0;
			// subcase 1: whole formula is false as well
			double valF1 = 0;
			for (int a : messages.keySet()) {
				if (a == atomID) continue;
				Message msg = messages.get(a);
				if (posAtoms.contains(a)) {
					valF1 += msg.negVal;
				} else if (negAtoms.contains(a)) {
					valF1 += msg.posVal;
				}
			}
			if (clause.weight > 0) valF1 += Math.abs(clause.weight);
			// subcase 2: whole formula is true
			double valF2 = 0;
			double minBumpToMakeTrue = Double.MAX_VALUE;
			for (int a : messages.keySet()) {
				if (a == atomID) continue;
				Message msg = messages.get(a);
				valF2 += Math.min(msg.negVal, msg.posVal);
				if ((posAtoms.contains(a) && msg.negVal >= msg.posVal) ||
						(negAtoms.contains(a) && msg.negVal <= msg.posVal)){ 
					// lower-cost truth and satisfying truth match
					// no need to make bump to satisfy formula
					minBumpToMakeTrue = 0;
				} else {
					// need to make a bump on this one to make formula true
					minBumpToMakeTrue = Math.min(minBumpToMakeTrue, 
							Math.abs(msg.negVal-msg.posVal));
				}
			}
			valF2 += minBumpToMakeTrue;
			if (clause.weight < 0) valF2 += Math.abs(clause.weight);

			//System.out.println("f1=" + valF1 + " , f2=" + valF2);
			valF = Math.min(valF1, valF2);

			Message ns = sentMessages.get(atomID);
			if (ns == null) {
				ns = new Message(atomID);
				sentMessages.put(atomID, ns);
			}
			if (posAtoms.contains(atomID)) {
				ns.posVal = valT;
				ns.negVal = valF;
			} else if (negAtoms.contains(atomID)) {
				ns.posVal = valF;
				ns.negVal = valT;
			}
			sentTo.add(atomID);
			return ns;
		}

		public FactorState(GClause gc) {
			clause = gc;
			for (int lit : gc.lits) {
				if (lit > 0) {
					posAtoms.add(lit);
				} else {
					negAtoms.add(-lit);
				}
			}
		}
	}

	HashMap<Integer, NodeState> states = new HashMap<Integer, NodeState>();
	WeakHashMap<GClause, FactorState> factors = new WeakHashMap<GClause, FactorState>();
	HashMap<Integer, ArrayList<GClause>> fidx = new HashMap<Integer, ArrayList<GClause>>();

	ArrayList<Object> nodeSequence = new ArrayList<Object>();
	HashSet<Object> processed = new HashSet<Object>();
	HashSet<Object> inQ = new HashSet<Object>();
	
	private void inferTree() {
		if (atoms.keySet().isEmpty()) {
			System.out.println("!!! EMPTY ATOMS");
			return;
		}
		nodeSequence.clear();
		processed.clear();
		inQ.clear();
		
		// init data structure and find leaves
		if (fidx.isEmpty()) {
			fidx = buildFactorGraphIndex();
		}
		if (states.isEmpty()) {
			for (int a : atoms.keySet()) {
				states.put(a, new NodeState(a));
				if (fidx.get(a) == null || fidx.get(a).size() == 1) {
					if (inQ.isEmpty()) {
						nodeSequence.add(atoms.get(a));
						inQ.add(atoms.get(a));
					}
				}
			}
		} else {
			for (int a : atoms.keySet()) {
				states.get(a).reset();
				if (fidx.get(a) == null || fidx.get(a).size() == 1) {
					if (inQ.isEmpty()) {
						nodeSequence.add(atoms.get(a));
						inQ.add(atoms.get(a));
					}
				}
			}
		}

		if (factors.isEmpty()) {
			for (GClause gc : clauses) {
				factors.put(gc, new FactorState(gc));
				if (gc.lits.length == 1) {
					if (inQ.isEmpty()) {
						nodeSequence.add(gc);
						inQ.add(gc);
					}
				}
			}
		} else {
			for (GClause gc : factors.keySet()) {
				factors.get(gc).reset();
				if (gc.lits.length == 1) {
					if (inQ.isEmpty()) {
						nodeSequence.add(gc);
						inQ.add(gc);
					}
				}
			}
		}

		// Build rooted tree with BFS
		int i = 0;
		while (i < nodeSequence.size()) {
			Object curNode = nodeSequence.get(i);
			processed.add(curNode);
			if (curNode instanceof GAtom) {
				for (GClause gc : fidx.get(((GAtom)curNode).id)) {
					if (processed.contains(gc)) continue;
					if (!inQ.contains(gc)) {
						nodeSequence.add(gc);
						inQ.add(gc);
					}
				}
			} else {
				for (int lit : ((GClause)curNode).lits) {
					int a = Math.abs(lit);
					GAtom ga = atoms.get(a);
					if (processed.contains(ga)) continue;
					if (!inQ.contains(ga)) {
						nodeSequence.add(ga);
						inQ.add(ga);
					}
				}
			}
			i++;
		}

		//System.out.println("    DOING TREE " + this + " with " + nodeSequence.size() + " nodes");
		Collections.reverse(nodeSequence);
		processed.clear();

		// First pass
		i = 0;
		while (i < nodeSequence.size()) {
			Object curNode = nodeSequence.get(i);
			processed.add(curNode);
			if (curNode instanceof GAtom) {
				NodeState ns = states.get(((GAtom)curNode).id);
				for (GClause gc : fidx.get(((GAtom)curNode).id)) {
					if (processed.contains(gc)) continue;
					Message msg = ns.genMsgForClause(gc);
					factors.get(gc).absorbNodeMessage(msg);
				}
			} else {
				FactorState fs = factors.get((GClause)curNode);
				for (int lit : ((GClause)curNode).lits) {
					int a = Math.abs(lit);
					GAtom ga = atoms.get(a);
					if (processed.contains(ga)) continue;
					Message msg = fs.genMsgForAtom(a);
					states.get(a).absorbFactorMessage((GClause)curNode, msg);
				}
			}
			i++;
		}

		// Second pass
		i = nodeSequence.size() - 1;
		while (i >= 0) {
			Object curNode = nodeSequence.get(i);
			if (curNode instanceof GAtom) {
				int a = ((GAtom)curNode).id;
				NodeState ns = states.get(a);
				for (GClause gc : fidx.get(a)) {
					if (ns.sentTo.contains(gc)) continue;
					boolean obit = ns.getOptBit();
					factors.get(gc).absorbBit(a, obit);
					Message msg = ns.genMsgForClause(gc);
					factors.get(gc).absorbNodeMessage(msg);
				}
			} else {
				FactorState fs = factors.get((GClause)curNode);
				for (int lit : ((GClause)curNode).lits) {
					int a = Math.abs(lit);
					if (fs.sentTo.contains(a)) continue;
					boolean obit = fs.getOptStateForAtom(a);
					NodeState ns = states.get(a);
					if (ns.truth == null) states.get(a).absorbBit(obit);
					Message msg = fs.genMsgForAtom(a);
					states.get(a).absorbFactorMessage((GClause)curNode, msg);
				}
			}
			i--;
		}

		// record states

		for (int a : atoms.keySet()) {
			GAtom ga = atoms.get(a);
			NodeState ns = states.get(a);
			if (ns.truth == null) ns.truth = false;
			ga.truth = ga.lowTruth = ns.truth;
		}

		lowCost = probCost();
	}

	private HashMap<Integer, ArrayList<GClause>> buildFactorGraphIndex() {
		HashMap<Integer, ArrayList<GClause>> adj = 
				new HashMap<Integer, ArrayList<GClause>>();
		for(GClause f : clauses){
			for(int lit : f.lits){
				ArrayList<GClause> plist = adj.get(Math.abs(lit));
				if(plist == null){
					plist = new ArrayList<GClause>();
					adj.put(Math.abs(lit), plist);
				}
				plist.add(f);
			}
		}
		return adj;
	}

	private WeakHashMap<GClause, MRF> clauseTreeMap = null;

	/**
	 * Decompose this MRF into a bunch of trees (or forests to be more precise)
	 * @return
	 */
	private ArrayList<MRF> decomposeTrees(HashMap<Integer, ArrayList<GClause>> adj) {
		clauseTreeMap = new WeakHashMap<GClause, MRF>();
		ArrayList<MRF> trees = new ArrayList<MRF>();
		HashSet<GClause> cpool = new HashSet<GClause>();
		// Collections.shuffle(clauses);
		LinkedList<GClause> llpool = new LinkedList<GClause>();
		llpool.addAll(clauses);
		cpool.addAll(clauses);
		while (!cpool.isEmpty()) {
			GClause root = cpool.iterator().next();
			root = llpool.getFirst();
			HashSet<GClause> edges = new HashSet<GClause>();
			HashSet<GClause> badEdges = new HashSet<GClause>();
			HashSet<Integer> nodes = new HashSet<Integer>();
			ArrayList<Integer> atomQ = new ArrayList<Integer>();
			edges.add(root);
			for (int lit : root.lits) nodes.add(Math.abs(lit));
			atomQ.addAll(nodes);
			int i = 0;
			while (i < atomQ.size()) {
				int curA = atomQ.get(i);
				for (GClause gc : adj.get(curA)) {
					if (!cpool.contains(gc) || badEdges.contains(gc) || 
							edges.contains(gc)) continue;
					boolean safe = true;
					for (int lit : gc.lits) {
						int a = Math.abs(lit);
						if (a == curA) continue;
						if (nodes.contains(a)) {
							safe = false;
							break;
						}
					}
					if (!safe) {
						badEdges.add(gc);
					} else {
						edges.add(gc);
						for (int lit : gc.lits) {
							int a = Math.abs(lit);
							if (a == curA) continue;
							nodes.add(a);
							atomQ.add(a);
						}
					}
				}
				i++;
			}

			MRF m = new MRF(mln);
			m.ownsAllAtoms = true;
			for (GClause gc : edges) {
				/*
				GClause ngc = new GClause();
				ngc.lits = gc.lits;
				ngc.weight = gc.weight;
				ngc.id = gc.id;
				*/
				m.clauses.add(gc);
				clauseTreeMap.put(gc, m);
			}
			for (int a : nodes) {
				GAtom ga = new GAtom(a);
				m.atoms.put(a, ga);
			}
			m.coreAtoms.addAll(m.atoms.keySet());
			trees.add(m);
			cpool.removeAll(edges);
			llpool.removeAll(edges);
		}
		return trees;
	}
	
	public static int totalTrees = 0;
	
	public static  synchronized void addTrees(int n) {
		totalTrees += n;
	}

	public static int totalCopies = 0;
	
	public static  synchronized void addCopies(int n) {
		totalCopies += n;
	}

	public void inferDualDecompMAP() {
		Timer.start("infer-mrf-" + this);
		assignAllFalseTruthValues();
		double c = probCost();
		saveLowTruth(c);
		expPrimalCosts.add(lowCost);
		expDualCosts.add(0.0);
		HashMap<Integer, ArrayList<GClause>> adj = buildFactorGraphIndex();
		ArrayList<MRF> trees = decomposeTrees(adj);
		MRF.addTrees(trees.size());

		if (debugTree || true) {
			//System.out.println("    Trees = " + trees.size());
			/*
			for (MRF m : trees) {
				System.out.println("MRF atoms=" + m.atoms.size() + 
						"  clauses=" + m.clauses.size());
				for (GClause gc : m.clauses) {
					System.out.println(gc);
				}
			}
			*/
		}
		
		HashMap<Integer, ArrayList<MRF>> atomTreeMap =
				new HashMap<Integer, ArrayList<MRF>>();
		int tcopies = 0;
		for (MRF m : trees) {
			for (int a : m.atoms.keySet()) {
				ArrayList<MRF> adjTrees = atomTreeMap.get(a);
				if (adjTrees == null) {
					adjTrees = new ArrayList<MRF>();
					atomTreeMap.put(a, adjTrees);
				}
				adjTrees.add(m);
				tcopies += 1;
			}
		}
		MRF.addCopies(tcopies);
		

		/*
		HashMap<Integer, Integer> histogram = new HashMap<Integer, Integer>();
		for (int a : atoms.keySet()) {
			ArrayList<MRF> lm = atomTreeMap.get(a);
			int adj = 0;
			if (lm != null) {
				adj = lm.size();
			}
			if (!histogram.containsKey(adj)) {
				histogram.put(adj, 1);
			} else {
				histogram.put(adj, 1 + histogram.get(adj));
			}
		}

		UIMan.setSilent(false);

		for (int pop : histogram.keySet()) {
			System.out.println("atom pop=" + pop + 
					"  freq=" + histogram.get(pop));
		}
		 */

		WeakHashMap<MRF, HashMap<Integer, Double>> lambdas =
				new WeakHashMap<MRF, HashMap<Integer,Double>>();
		double ss = Config.mrf_dd_ss_init;
		int maxEpochs = Config.mrf_dd_max_iterations;
		int epoch = 1;
		double error = 1;
		double dualCost = 0;
		while (epoch <= maxEpochs && error > 0.0001) {
			if (epoch > 1) ss *= Config.mrf_dd_ss_diminish;
			if (Config.mrf_dd_ss_divergent) ss = 1.0 / epoch;
			if (epoch > 3) {
				//for (MRF m : trees) m.debugTree = true;
			} else if (epoch == 2){
				for (MRF m : trees) {
					//if (m.clauses.size()==1 && m.atoms.size() == 3) m.debugTree = true;
				}
				
			}
			/*
			double nc = 0;
			for (MRF m : trees) {
				if (m.singletons == null) continue;
				for (GClause gc : m.singletons.values()) nc += Math.abs(gc.weight);
			}
			System.out.println("EPOCH #" + epoch + ", nc = " + nc);
			*/
			for (MRF m : trees) {
				m.inferTree();
				if (epoch == 1) {
					if (debugTree) {
						System.out.println(m.probCostExcludingMultipliers());
						for (GAtom ga : m.atoms.values()) {
							System.out.println(ga.id + " = " + ga.truth);
						}
					}
					dualCost += m.probCostExcludingMultipliers();
					lambdas.put(m, new HashMap<Integer, Double>());
				} else {
					lambdas.get(m).clear();
				}
			}

			if (epoch == 1) {
				//System.out.println("    dual cost = " + dualCost);
			}

			double totalVar = 0;
			for (int a : atomTreeMap.keySet()) {
				int ncopies = atomTreeMap.get(a).size();
				double total = 0;
				for (MRF m : atomTreeMap.get(a)) {
					total += (m.atoms.get(a).lowTruth ? 1 : 0);
				}
				double mean = total / ncopies;
				double var = 0;
				for (MRF m : atomTreeMap.get(a)) {
					double v = (m.atoms.get(a).lowTruth ? 1 : 0);
					var += Math.pow(v - mean, 2);
					lambdas.get(m).put(a, (mean - v) * ss);
					//System.out.println("atom-delta " + a + ":" + (mean - v) + " * " + ss);
				}
				var /= ncopies;
				totalVar += var;
				atoms.get(a).truth = (mean > 0.5);
				//System.out.println("atom" + a + ":" + atoms.get(a).truth + " , " + mean);
			}

			boolean orderedPrimalAssignment = true; //Config.mrf_dd_sequential_merge;

			if (orderedPrimalAssignment) {
				HashMap<Integer, Boolean> fixedVals = 
						new HashMap<Integer, Boolean>();
				ArrayList<Integer> alist = new ArrayList<Integer>();
				alist.addAll(atomTreeMap.keySet());
				Collections.shuffle(alist);
				for (int a : alist) {
					double valF = 0, valT = 0;
					for (GClause gc : adj.get(a)) {
						// check if already sat
						int alit = 0;
						Boolean sat = null;
						boolean hasOtherOpenAtom = false;
						for (int lit : gc.lits) {
							int aa = Math.abs(lit);
							if (aa == a) alit = lit;
							Boolean bb = fixedVals.get(aa);
							if (bb != null && bb == (lit > 0)) {
								sat = true;
							} else if (bb == null && aa != a) {
								hasOtherOpenAtom = true;
							}
						}
						// tie if already sat
						if (sat != null && sat == true) continue;
						// sat determined by this atom alone
						if (!hasOtherOpenAtom) {
							boolean satOnF = (alit < 0);
							double costOnF = 0, costOnT = 0;
							if (satOnF && gc.weight < 0 ||
									!satOnF && gc.weight > 0) {
								costOnF = Math.abs(gc.weight);
							} else {
								costOnT = Math.abs(gc.weight);
							}
							valF += costOnF;
							valT += costOnT;
						} else {
							// has other open atoms
							MRF m = clauseTreeMap.get(gc);
							NodeState ns = m.states.get(a);
							Message msg = ns.messages.get(gc);
							valF += msg.negVal;
							valT += msg.posVal;
						}
					}
					boolean val = (valF > valT);
					fixedVals.put(a, val);
					atoms.get(a).truth = val;
				}
			}

			double pcost = recalcCost();
			saveLowTruth(pcost);
			if (debugTree) UIMan.setSilent(false);
			UIMan.println("    ======");
			UIMan.println("    epoch = " + epoch + "; trees = " + trees.size());
			UIMan.println("    dual cost = " + dualCost);
			UIMan.println("    primal cost = " + pcost);
			UIMan.println("    low cost = " + lowCost);
			UIMan.println("    variance = " + totalVar);
			expDualCosts.add(totalVar);
			expPrimalCosts.add(lowCost);

			if (pcost + 0.001 < dualCost) {
				System.out.println("primal=" + pcost + " ; dual=" + dualCost);
				for (MRF m : trees) {
					System.out.println("TREEEEE cost=" + m.lowCost);
					for (GClause gc : m.clauses) System.out.println(gc);
				}
				ExceptionMan.die("aa");
			}

			for (MRF m : trees) {
				m.updateSingletonClauses(lambdas.get(m), false);
			}

			error = totalVar;
			if (pcost - 0.001 <= dualCost) {
				error = 0;
			}
			epoch++;
		}

		for (MRF m : trees) {
			m.discard();
		}
		/*
		for (int a : atoms.keySet()) {
			System.out.println("atom" + a + ":" + atoms.get(a).lowTruth);
		}
		*/
		UIMan.setSilent(true);
		expInferenceTime = Timer.elapsedSeconds("infer-mrf-" + this);
	}


	/**
	 * Run WalkSAT.
	 * @param nTries number of tries
	 * @param nSteps number of steps per try
	 */
	public void inferWalkSAT(int nTries, long nSteps){
		ArrayList<GClause> ng = new ArrayList<GClause>();
		for (GClause c : clauses) {
			HashSet<Integer> plits = new HashSet<Integer>();
			boolean bad = false;
			for (int lit : c.lits) {
				if (plits.contains(-lit)) {
					bad = true;
					break;
				}
				plits.add(lit);
			}
			if (!bad) ng.add(c);
		}
		clauses = ng;
		if (Config.mrf_dual_decomposition) {
			inferDualDecompMAP();
		} else {
			this.inferWalkSATwithoutBlocking(nTries, nSteps);
			//this.inferWalkSATwithBlocks(nTries, nSteps);
		}
	}

	@SuppressWarnings("unchecked")
	public void inferWalkSAT(int nTries, long nSteps, HashSet<Integer> notChanges){
		if(Config.use_atom_blocking == false){
			this.inferWalkSATwithoutBlocking(nTries, nSteps, notChanges);
		}else{
			this.inferWalkSATwithBlocks(nTries, nSteps);
		}
		UIMan.setSilent(false);
	}

	/**
	 * Run WalkSAT.
	 * @param nTries number of tries
	 * @param nSteps number of steps per try
	 */
	private synchronized void inferWalkSATwithoutBlocking(int nTries, 
			long nSteps, HashSet<Integer>... notChanges){
		if(atoms.size() == 0){
			return;
		}
		Timer.start("infer-mrf-" + this);

		assignAllFalseTruthValues();
		lowCost = probCost();
		expPrimalCosts.add(lowCost);

		HashSet<Integer> notChange = null;
		if(notChanges.length == 1){
			notChange = notChanges[0];
		}

		if(nSteps < 10) nSteps = 10;
		if(!Config.learning_mode) UIMan.println("    Running WalkSAT for " + nTries +
				" tries, " + UIMan.comma(nSteps) + " flips/try");
		if(adj.isEmpty()) buildIndices();
		Random rand = new Random();
		// low cost of periodic flushing
		for(long itry=1; itry<=nTries; itry++){
			if(!Config.learning_mode)  UIMan.println("[Try #" + itry + "/" + nTries + "]");
			if(notChanges.length == 0){
				initMRF();
			}else{
				if(usingBlocks)	maintainKeyConstraints();
				lowCost = calcCosts();
				dirtyAtoms.clear();
				saveTruthAsLow();
			}
			for(long flip = 1; flip <= nSteps; flip++){
				if (flip % (nSteps/10) == 0 || flip == nSteps) {
					expPrimalCosts.add(lowCost);
				}
				// check if we have reached terminal condition
				if(unsat.isEmpty()){
					if(!Config.learning_mode)   UIMan.println("Resolved!");
					saveLowTruth(totalCost);
					expPrimalCosts.add(lowCost);
					expInferenceTime = Timer.elapsedSeconds("infer-mrf-" + this);
					return;
				}
				// pick random unsat clause
				GClause lucky = unsat.getRandomElement();
				// pick an atom therein
				int picked = 0;
				if(lucky.isPositiveClause()){
					// a positive clause
					if(testChance(Config.walksat_random_step_probability)){
						// a random step
						picked = -1;

						if(notChange != null){
							boolean skip = true;
							for(int luckylit : lucky.lits){
								if(!notChange.contains(Math.abs(luckylit))){
									skip = false;
								}
							}
							if(skip == true){
								continue;
							}
						}

						while(picked == -1 || !ownsAtom(picked, notChange) ){
							picked = Math.abs(lucky.lits[rand.nextInt(lucky.lits.length)]);
						}
					}else{
						// a greedy step
						double minDelta = Double.MAX_VALUE;
						int nrivals = 0;
						for(int lit : lucky.lits){
							int a = Math.abs(lit);
							if(!ownsAtom(a, notChange)) continue;
							if(atoms.get(a).delta() < minDelta){
								picked = a;
								minDelta = atoms.get(a).delta();
								nrivals = 1;
							}else if(atoms.get(a).delta() == minDelta){
								if(testChance(1.0/(++nrivals))){
									picked = a;
								}
							}
						}
					}
					if(picked == 0){
						System.out.println();
					}
				}else{
					// a negative clause
					ArrayList<Integer> cands = new ArrayList<Integer>();
					for(int lit : lucky.lits){
						if(isTrueLit(lit) && ownsAtom(Math.abs(lit), notChange)   ){
							cands.add(Math.abs(lit));
						}
					}

					if(cands.size() == 0){
						continue;
					}
					if(cands.size() == 1){
						picked = cands.get(0);
					}else{
						if(testChance(Config.walksat_random_step_probability)){
							// a random step
							picked = cands.get(rand.nextInt(cands.size()));
						}else{
							// a greedy step
							double minDelta = Double.MAX_VALUE;
							int nrivals = 0;
							for(int a : cands){
								if(atoms.get(a).delta() < minDelta){
									picked = a;
									minDelta = atoms.get(a).delta();
									nrivals = 1;
								}else if(atoms.get(a).delta() == minDelta){
									if(testChance(1.0/(++nrivals))){
										picked = a;
									}
								}
							}
						}
					}

					if(picked == 0){
						System.out.println();
					}
				}

				//if(picked == 0) continue;
				inferOps ++;
				if(flip==1 || flip==nSteps || flip % (nSteps/4) == 0){
					if(!Config.learning_mode)   UIMan.verbose(1, "At flip "+UIMan.comma(flip)+
							"/" + UIMan.comma(nSteps) + ";\tcost = " + UIMan.comma(lowCost));
				}
				if(!ownsAtom(picked, notChange)) continue;
				GAtom atom = atoms.get(picked);

				if(Config.avoid_breaking_hard_clauses && 
						atom.criticalForHardClauses()) continue;

				if(Config.apply_greedy_throttling && 
						atom.delta() > 0 && 
						testChance(0.95)){
					continue;
				}
				// flip this atom
				Timer.runStat.effectiveSteps++;

				//double oldTotal = totalCost;

				totalCost += atom.delta();
				atom.truth = !atom.truth;

				//double expected = totalCost;

				dirtyAtoms.add(picked);
				atom.invertDelta();
				if(totalCost < lowCost){
					saveLowTruth(totalCost);
				}
				// update stats
				ArrayList<GClause> tlfac, flfac;
				if(atom.truth){
					tlfac = adj.get(atom.id);
					flfac = adj.get(-atom.id);


				}else{
					flfac = adj.get(atom.id);
					tlfac = adj.get(-atom.id);

				}
				if(tlfac != null){
					for(GClause f : tlfac){
						++ f.nsat;
						int nsat = f.nsat;
						if(nsat==1){
							if(f.weight >= 0) {
								unsat.removeObj(f);
							}else{
								unsat.add(f);
							}
							for(int lit : f.lits){
								int a = Math.abs(lit);
								if(a==picked || !ownsAtom(a, notChange)) continue;
								atoms.get(a).revokeSatPotential(f);
							}
						}else if(nsat==2){
							for(int lit : f.lits){
								int a = Math.abs(lit);
								if(a==picked || !ownsAtom(a, notChange)) continue;
								GAtom n = atoms.get(a);
								if((lit>0) == n.truth && willChange(lit, f.lits)){
									n.revokeUnsatPotential(f);
									break;
								}
							}
						}
					}
				}
				if(flfac != null){
					for(GClause f : flfac){
						-- f.nsat;
						int nsat = f.nsat;
						if(nsat==0){
							if(f.weight <= 0) {
								unsat.removeObj(f);
							}else{
								unsat.add(f);
							}
							for(int lit : f.lits){
								int a = Math.abs(lit);
								if(a==picked || !ownsAtom(a, notChange)) continue;
								atoms.get(a).assignSatPotential(f);
							}
						}else if(nsat==1){
							for(int lit : f.lits){
								int a = Math.abs(lit);
								if(a==picked || !ownsAtom(a, notChange)) continue;
								GAtom n = atoms.get(a);
								if((lit>0) == n.truth && willChange(lit, f.lits)){
									n.assignUnsatPotential(f);
									break;
								}
							}
						}
					}
				}

				/*
				double newcost = this.recalcCostNotOverrideOldCost();
				if( newcost != expected){
					if(Math.abs(newcost - expected) > 0.1){
						System.out.println();
					}
					System.out.println(newcost - expected);
				}
				 */
			}
		}

		expInferenceTime = Timer.elapsedSeconds("infer-mrf-" + this);
	}

	public boolean willChange(int lit, int[] lits){
		for(int a : lits){
			if(a == -lit){
				return false;
			}
		}
		return true;
	}

	/**
	 * Run WalkSAT with blocks.
	 * @param nTries number of tries
	 * @param nSteps number of steps per try
	 */
	private void inferWalkSATwithBlocks(int nTries, long nSteps){

		//TODO: CHECK KEYBLOCK AND PARTITIONING

		if(atoms.size() == 0){
			return;
		}
		Timer.start("infer-mrf-" + this);

		assignAllFalseTruthValues();
		lowCost = probCost();
		expPrimalCosts.add(lowCost);

		if(nSteps < 10) nSteps = 10;
		//System.out.print(".");
		UIMan.println(">>> Running WalkSAT for " + nTries +
				" tries, " + UIMan.comma(nSteps) + " flips/try");
		if(adj.isEmpty()) buildIndices();
		Random rand = new Random();
		// low cost of periodic flushing
		for(int itry=1; itry<=nTries; itry++){
			UIMan.println("[Try #" + itry + "/" + nTries + "]");
			initMRF();

			for(long flip = 1; flip <= nSteps; flip++){

				if (flip % (nSteps/10) == 0 || flip == nSteps) {
					expPrimalCosts.add(lowCost);
				}
				//	if(flip % 1000 == 0){
				//		this.testKeyConstraints();
				//	}

				// check if we have reached terminal condition
				if(unsat.isEmpty()){
					UIMan.println("resolved!");
					saveLowTruth(totalCost);
					expPrimalCosts.add(lowCost);
					expInferenceTime = Timer.elapsedSeconds("infer-mrf-" + this);
					return;
				}
				// pick random unsat clause
				GClause lucky = unsat.getRandomElement();
				// pick an atom therein
				int picked = 0;
				if(lucky.isPositiveClause()){
					// a positive clause
					if(testChance(Config.walksat_random_step_probability)){
						// a random step
						picked = -1;
						while(picked == -1 || !ownsAtom(picked)){
							picked = Math.abs(lucky.lits[rand.nextInt(lucky.lits.length)]);
						}
					}else{
						// a greedy step
						double minDelta = Double.MAX_VALUE;
						int nrivals = 0;
						for(int lit : lucky.lits){
							int a = Math.abs(lit);
							if(!ownsAtom(a)) continue;
							if(atoms.get(a).delta() < minDelta){
								picked = a;
								minDelta = atoms.get(a).delta();
								nrivals = 1;
							}else if(atoms.get(a).delta() == minDelta){
								if(testChance(1.0/(++nrivals))){
									picked = a;
								}
							}
						}
						if(minDelta > 0){
							continue;
						}
					}
				}else{
					// a negative clause
					ArrayList<Integer> cands = new ArrayList<Integer>();
					for(int lit : lucky.lits){
						if(isTrueLit(lit) && ownsAtom(Math.abs(lit))){
							cands.add(Math.abs(lit));
						}
					}
					if(cands.size() == 1){
						picked = cands.get(0);
						if(atoms.get(picked).delta() > 0){
							continue;
						}
					}else{
						if(testChance(Config.walksat_random_step_probability)){
							// a random step
							picked = cands.get(rand.nextInt(cands.size()));
						}else{
							// a greedy step
							double minDelta = Double.MAX_VALUE;
							int nrivals = 0;
							for(int a : cands){
								if(atoms.get(a).delta() < minDelta){
									picked = a;
									minDelta = atoms.get(a).delta();
									nrivals = 1;
								}else if(atoms.get(a).delta() == minDelta){
									if(testChance(1.0/(++nrivals))){
										picked = a;
									}
								}
							}
							if(minDelta > 0){
								continue;
							}
						}
					}
				}

				//if(picked == 0) continue;
				inferOps ++;
				if(flip % (nSteps/4) == 1){
					UIMan.verbose(1, "At flip "+UIMan.comma(flip)+
							"/" + UIMan.comma(nSteps));
				}
				if(!ownsAtom(picked)) continue;
				GAtom atom = atoms.get(picked);
				if(Config.avoid_breaking_hard_clauses && 
						atom.criticalForHardClauses()) continue;

				if(Config.apply_greedy_throttling && 
						atom.delta() > 0 && 
						testChance(0.7)){
					continue;
				}

				// flip this atom
				Timer.runStat.effectiveSteps++;

				totalCost += atom.delta();

				ArrayList<GAtom> influenced = atom.flip(keyBlock);
				//atom.truth = !atom.truth;
				for(GAtom n : influenced){
					dirtyAtoms.add(n.id);
				}

				if(totalCost < lowCost){
					saveLowTruth(totalCost);
					UIMan.verbose(1, "newLowCost=" + UIMan.comma(lowCost) + 
							" at flip #" + UIMan.comma(flip));
				}

				// update stats
				ArrayList<GClause> tlfac = new ArrayList<GClause>();
				ArrayList<GClause> flfac = new ArrayList<GClause>();

				//TODO
				if(influenced.isEmpty()){

					atom.invertDelta();

					if(atom.truth){
						if(adj.get(atom.id) != null)	tlfac.addAll(adj.get(atom.id));
						if(adj.get(-atom.id) != null)	flfac.addAll(adj.get(-atom.id));
					}else{
						if(adj.get(atom.id) != null)	flfac.addAll(adj.get(atom.id));
						if(adj.get(-atom.id) != null)	tlfac.addAll(adj.get(-atom.id));
					}

					this.adjustAtomClauseRelation(tlfac, flfac, picked);

				}else{

					// update f-nsat
					ArrayList<GClause> addNSAT = new ArrayList<GClause>();
					ArrayList<GClause> minusNSAT = new ArrayList<GClause>();
					HashSet<GClause> allGCs = new HashSet<GClause>();
					HashSet<Integer> needToReCalcCost = new HashSet<Integer>();

					for(GAtom toFlip : influenced ){
						if(toFlip.truth == false){
							if(adj.containsKey(toFlip.id)) minusNSAT.addAll(adj.get(toFlip.id));
							if(adj.containsKey(-toFlip.id)) addNSAT.addAll(adj.get(-toFlip.id));
						}else{
							if(adj.containsKey(-toFlip.id)) minusNSAT.addAll(adj.get(-toFlip.id));
							if(adj.containsKey(toFlip.id)) addNSAT.addAll(adj.get(toFlip.id));
						}
					}
					for(GClause gc : minusNSAT){
						gc.nsat --;
						allGCs.add(gc);
					}
					for(GClause gc : addNSAT){
						gc.nsat ++;
						allGCs.add(gc);
					}
					double realCost = 0.0;
					for(GClause gc : allGCs){
						for(int a : gc.lits){
							needToReCalcCost.add(Math.abs(a));
						}
						if(gc.weight >= 0){
							if(gc.nsat > 0){
								if(unsat.contains(gc)){
									realCost -= Math.abs(gc.weight);
								}
								unsat.removeObj(gc);
							}else{
								if(!unsat.contains(gc)){
									realCost += Math.abs(gc.weight);
								}
								unsat.add(gc);
							}
						}else{
							if(gc.nsat > 0){
								if(!unsat.contains(gc)){
									realCost += Math.abs(gc.weight);
								}
								unsat.add(gc);
							}else{
								if(unsat.contains(gc)){
									realCost -= Math.abs(gc.weight);
								}
								unsat.removeObj(gc);
							}
						}
					}

					if(Math.abs(realCost - atom.delta()) > 0.1 ){
						System.err.println("REALCOST != ESTIMATED COST ERROR");
					}

					this.calcCostsForWalkSAT(needToReCalcCost);

				}

			}
		}
		expInferenceTime = Timer.elapsedSeconds("infer-mrf-" + this);
		UIMan.println("### lowest cost = " + UIMan.comma(lowCost));
	}


	private void adjustAtomClauseRelation(ArrayList<GClause> tlfac, ArrayList<GClause> flfac, int picked){
		if(tlfac.size() != 0){
			for(GClause f : tlfac){
				++ f.nsat;
				int nsat = f.nsat;
				if(nsat==1){
					if(f.weight >= 0) {
						unsat.removeObj(f);
					}else{
						unsat.add(f);
					}
					for(int lit : f.lits){
						int a = Math.abs(lit);
						if(a==picked || !ownsAtom(a)) continue;
						atoms.get(a).revokeSatPotential(f);
					}
				}else if(nsat==2){
					for(int lit : f.lits){
						int a = Math.abs(lit);
						if(a==picked || !ownsAtom(a)) continue;
						GAtom n = atoms.get(a);
						if((lit>0) == n.truth){
							n.revokeUnsatPotential(f);
							break;
						}
					}
				}
			}
		}
		if(flfac.size() != 0){
			for(GClause f : flfac){
				-- f.nsat;
				int nsat = f.nsat;
				if(nsat==0){
					if(f.weight <= 0) {
						unsat.removeObj(f);
					}else{
						unsat.add(f);
					}
					for(int lit : f.lits){
						int a = Math.abs(lit);
						if(a==picked || !ownsAtom(a)) continue;
						atoms.get(a).assignSatPotential(f);
					}
				}else if(nsat==1){
					for(int lit : f.lits){
						int a = Math.abs(lit);
						if(a==picked || !ownsAtom(a)) continue;
						GAtom n = atoms.get(a);
						if((lit>0) == n.truth){
							n.assignUnsatPotential(f);
							break;
						}
					}
				}
			}
		}
	}

	/**
	 * Run SweepSAT for MAP inference.
	 * @param nTries number of tries
	 * @param nSteps number of steps per try
	 * @deprecated
	 */
	public void inferSweepSAT(int nTries, int nSteps){
		DebugMan.checkPeakMem();
		UIMan.println(">>> Running SweepSAT for " + nTries +
				" tries, " + nSteps + " flips/try");

		for(int itry=1; itry<=nTries; itry++){
			UIMan.println("[Try #" + itry + "/" + nTries + "]");
			initMRF();
			int nflips = 0;
			while(nflips < nSteps){
				int numGood = 0;
				if(ownsAllAtoms){
					for(GAtom n : atoms.values()){
						if(n.delta() < 0){
							++ numGood;
							if(testChance(Config.sweepsat_greedy_probability)){
								n.flip();
								nflips ++;
								inferOps ++;
								Timer.runStat.effectiveSteps++;
							}
						}
					}
					if(numGood == 0){
						for(GAtom n : atoms.values()){
							if(testChance(0.5)){
								if(!Config.avoid_breaking_hard_clauses || !n.criticalForHardClauses()){
									n.flip();
									nflips ++;
									inferOps ++;
									Timer.runStat.effectiveSteps++;
								}
							}
						}
					}
				}else{
					for(int aid : getCoreAtoms()){
						GAtom n = atoms.get(aid);
						if(n.delta() < 0){
							++ numGood;
							if(testChance(Config.sweepsat_greedy_probability)){
								n.flip();
								nflips ++;
								inferOps ++;
								Timer.runStat.effectiveSteps++;
							}
						}
					}
					if(numGood == 0){
						for(int aid : getCoreAtoms()){
							GAtom n = atoms.get(aid);
							if(testChance(0.5)){
								if(!Config.avoid_breaking_hard_clauses || !n.criticalForHardClauses()){
									n.flip();
									nflips ++;
									inferOps ++;
									Timer.runStat.effectiveSteps++;
								}
							}
						}
					}
				}

				calcCosts();
				if(totalCost < lowCost){
					saveLowTruth(totalCost);
					UIMan.println("["+nflips+"]low=" + lowCost);
					if(lowCost == 0){
						UIMan.println("--all violations gone, cost = " + totalCost);
						return;
					}
				}
			}
		}
		DebugMan.checkPeakMem();
	}



	/**
	 * Initialize the state of the MRF.
	 */
	public void initMRF() {
		switch(initStrategy){
		case ALL_FALSE:
			assignAllFalseTruthValues();
			break;
		case COIN_FLIP:
			assignRandomTruthValues();
			break;
		case GREEDY:
			assignGreedyTruthValues();
			break;
		case COPY_LOW:
			restoreLowTruth();
			break;
		case NO_CHANGE:
			break;
		}
		if(usingBlocks)	maintainKeyConstraints();
		lowCost = calcCosts();
		dirtyAtoms.clear();
		saveTruthAsLow();
	}

	private void maintainKeyConstraints(){
		for(GAtom n : atoms.values()){
			if(!keyBlock.hasKey(n)){
				continue;
			}

			if(n.truth == true){
				ArrayList<GAtom> mates = keyBlock.getBlockMates(n);
				for(GAtom shouldBeFalse : mates){
					shouldBeFalse.truth = false;
				}
			}
		}
	}

	/**
	 * Set all atoms to false.
	 */
	private void assignAllFalseTruthValues(){
		if(ownsAllAtoms){
			for(GAtom n : atoms.values()){
				n.truth = false;
			}
		}else{
			for(int aid : getCoreAtoms()){
				atoms.get(aid).truth = false;
			}
		}
	}

	/**
	 * Set random atom truth values.
	 */
	private void assignRandomTruthValues(){
		Random rand = new Random();
		if(ownsAllAtoms){
			for(GAtom n : atoms.values()){
				if(n.fixed || (Config.focus_on_critical_atoms && !n.critical())) continue;
				n.truth = rand.nextBoolean();
			}
		}else{
			for(int aid : getCoreAtoms()){
				GAtom n = atoms.get(aid);
				if(n.fixed || (Config.focus_on_critical_atoms && !n.critical())) continue;
				n.truth = rand.nextBoolean();
			}
		}
	}

	/**
	 * Assign inital truth values according to some
	 * ad hoc and heuristic stats.
	 */
	private void assignGreedyTruthValues(){
		HashMap<Integer, Double> wts = new HashMap<Integer, Double>();
		if(ownsAllAtoms){
			for(GAtom n : atoms.values()){
				wts.put(n.id, 0.0);
			}
		}else{
			for(int aid : getCoreAtoms()){
				wts.put(aid, 0.0);
			}
		}
		for(GClause f : clauses){
			if(!ownsAllAtoms && isAlwaysTrue(f)) continue;
			for(int lit : f.lits){
				int a = Math.abs(lit);
				Double prev = wts.get(a);
				if(prev != null){
					wts.put(a, prev + Math.signum(lit) * f.weight);
				}
			}
		}
		for(int aid : wts.keySet()){
			GAtom n = atoms.get(aid);
			if(wts.get(n.id) > 0){
				n.truth = true;
			}else{
				n.truth = false;
			}
		}
	}

	// TODO: NEED TO CHANGE THIS FUNCTION FOR READING DATA.
	// CURRENTLY, IT IS THE SAME OF RANDOM!!!!!!!
	///**
	// * Assign initial truth value according to training data. 
	// * 
	// * CURRENTLY, IT IS THE SAME OF RANDOM!!!!!!!
	// * NEED TO CHANGE.
	// */
	/*private void assignTruthValuesAccording2TrainingData(){
		Random rand = new Random();
		if(ownsAllAtoms){
			for(GAtom n : atoms.values()){
				if(n.fixed || (Config.focus_on_critical_atoms && !n.critical())) continue;
				n.truth = rand.nextBoolean();
			}
		}else{
			for(int aid : coreAtoms){
				GAtom n = atoms.get(aid);
				if(n.fixed || (Config.focus_on_critical_atoms && !n.critical())) continue;
				n.truth = rand.nextBoolean();
			}
		}
	}*/

	/**
	 * Calculate the number of true literals in a clause.
	 * @param f
	 */
	private void calcNSAT(GClause f){
		int nsat = 0;
		for(int lit : f.lits){
			if(isTrueLit(lit)){
				nsat++;
			}
		}
		f.nsat = nsat;
	}

	private ArrayList<GAtom> getFlipSequence(GAtom a){
		ArrayList<GAtom> ret = new ArrayList<GAtom>();

		if(a.truth == true || keyBlock.hasKey(a) == false){
			ret.add(a);
			return ret;
		}else{

			ArrayList<GAtom> mates = keyBlock.getBlockMates(a);
			for(GAtom g : mates){
				if(g == a || g.truth == true){
					ret.add(g);
				}
			}
			return ret;
		}

	}


	public double probCostExcludingMultipliers(){
		double cost = 0;
		for(GClause f : clauses) {
			if (singletons != null && singletons.containsValue(f)) continue; 
			calcNSAT(f);
			cost += f.cost();
		}
		return cost;
	}

	public double probCost(){
		double cost = 0;
		for(GClause f : clauses){
			calcNSAT(f);
			cost += f.cost();
		}
		return cost;
	}


	/**
	 * Compute total cost and per-atom delta cost.
	 * The delta cost of an atom is the change in the total cost if
	 * this atom is flipped.
	 * @return total cost
	 */
	protected double calcCostsFast(){
		totalCost = 0;
		unsat.clear();
		// reset stats
		if(ownsAllAtoms){
			for(GAtom n : atoms.values()){
				n.resetDelta();
			}
		}else{
			for(int aid : getCoreAtoms()){
				atoms.get(aid).resetDelta();
			}
		}

		// recompute stats
		for(GClause f : clauses){
			calcNSAT(f);
			if(f.dead) continue;
			totalCost += f.cost();
			if(!ownsAllAtoms && isAlwaysTrue(f)){
				continue;
			}
			if(f.cost() > 0){
				unsat.add(f);
			}
		}

		return totalCost;
	}


	/**
	 * Compute total cost and per-atom delta cost.
	 * The delta cost of an atom is the change in the total cost if
	 * this atom is flipped.
	 * @return total cost
	 */
	protected double calcCosts(){
		totalCost = 0;
		unsat.clear();
		// reset stats
		if(ownsAllAtoms){
			for(GAtom n : atoms.values()){
				n.resetDelta();
			}
		}else{
			for(int aid : getCoreAtoms()){
				atoms.get(aid).resetDelta();
			}
		}

		// recompute stats
		for(GClause f : clauses){
			calcNSAT(f);
			if(f.dead) continue;
			totalCost += f.cost();
			if(!ownsAllAtoms && isAlwaysTrue(f)){
				continue;
			}
			if(f.cost() > 0){
				unsat.add(f);
			}
		}

		for(GAtom n : atoms.values()){

			if(!ownsAllAtoms){	//TODO: CHECK
				if(!getCoreAtoms().contains(n.id)){
					continue;
				}
			}

			ArrayList<GAtom> flips = this.getFlipSequence(n);
			ArrayList<GClause> addNSAT = new ArrayList<GClause>();
			ArrayList<GClause> minusNSAT = new ArrayList<GClause>();

			for(GAtom toFlip : flips ){
				if(toFlip.truth == true){
					if(adj.containsKey(toFlip.id)) minusNSAT.addAll(adj.get(toFlip.id));
					if(adj.containsKey(-toFlip.id)) addNSAT.addAll(adj.get(-toFlip.id));
				}else{
					if(adj.containsKey(-toFlip.id)) minusNSAT.addAll(adj.get(-toFlip.id));
					if(adj.containsKey(toFlip.id)) addNSAT.addAll(adj.get(toFlip.id));
				}
			}

			//TODO: CHANGE TO MORE EFFICIENT DATA STRUCTURE
			HashMap<GClause, Integer> delta = new HashMap<GClause, Integer>();
			for(GClause gc : minusNSAT){
				if(!delta.containsKey(gc)){
					delta.put(gc, 0);
				}
				delta.put(gc, delta.get(gc)-1);
			}
			for(GClause gc : addNSAT){
				if(!delta.containsKey(gc)){
					delta.put(gc, 0);
				}
				delta.put(gc, delta.get(gc)+1);
			}

			for(GClause gc : delta.keySet()){

				Integer del = delta.get(gc);

				if(gc.nsat > 0 && gc.nsat + del <= 0){
					n.assignUnsatPotential(gc);
				}else if (gc.nsat == 0 && gc.nsat + del > 0){
					n.assignSatPotential(gc);
				}

			}
		}

		return totalCost;
	}


	private double calcCostsForWalkSAT(HashSet<Integer> needToBeReset){

		HashSet<Integer> afterClosure = new HashSet<Integer>();
		/*	
		if(ownsAllAtoms){
			for(GAtom n : atoms.values()){
				afterClosure.add(n.id);
			}
		}else{
			for(int aid : coreAtoms){
				afterClosure.add(aid);
			}
		}
		 */

		for(Integer _n : needToBeReset){

			GAtom n = atoms.get(_n);
			afterClosure.add(_n);
			ArrayList<GAtom> mates = keyBlock.getBlockMates(n);

			if(mates == null){
				//System.err.println("MATE = NULL");
				continue;
			}

			for(GAtom mate : mates){
				afterClosure.add(mate.id);
			}

		}

		for(Integer _n : afterClosure){

			GAtom n = atoms.get(_n);
			n.resetDelta();

			//if(!ownsAllAtoms){	//TODO: CHECK
			//	if(!coreAtoms.contains(n.id)){
			//		continue;
			//	}
			//}

			ArrayList<GAtom> flips = this.getFlipSequence(n);
			ArrayList<GClause> addNSAT = new ArrayList<GClause>();
			ArrayList<GClause> minusNSAT = new ArrayList<GClause>();

			for(GAtom toFlip : flips ){
				if(toFlip.truth == true){
					if(adj.containsKey(toFlip.id)) minusNSAT.addAll(adj.get(toFlip.id));
					if(adj.containsKey(-toFlip.id)) addNSAT.addAll(adj.get(-toFlip.id));
				}else{
					if(adj.containsKey(-toFlip.id)) minusNSAT.addAll(adj.get(-toFlip.id));
					if(adj.containsKey(toFlip.id)) addNSAT.addAll(adj.get(toFlip.id));
				}
			}

			//TODO: CHANGE TO MORE EFFICIENT DATA STRUCTURE
			HashMap<GClause, myInt> delta = new HashMap<GClause, myInt>();
			for(GClause gc : minusNSAT){
				if(!delta.containsKey(gc)){
					delta.put(gc, new myInt(0));
				}
				delta.get(gc).subOne();
			}
			for(GClause gc : addNSAT){
				if(!delta.containsKey(gc)){
					delta.put(gc, new myInt(0));
				}
				delta.get(gc).addOne();
			}

			for(GClause gc : delta.keySet()){

				Integer del = delta.get(gc).value;

				if(gc.nsat > 0 && gc.nsat + del <= 0){
					n.assignUnsatPotential(gc);
				}else if (gc.nsat == 0 && gc.nsat + del > 0){
					n.assignSatPotential(gc);
				}

			}
		}

		return totalCost;
	}

	/**
	 * Track ground clause violations to fo-clauses.
	 * Stats are records on a per fo-clause basis.
	 * 
	 * @see	tuffy.helper.Stats#reportMostViolatedClauses
	 */
	public void auditClauseViolations(){
		restoreLowTruth();
		totalCost = 0;
		for(Clause c : mln.getAllNormalizedClauses()){
			c.cost = 0;
			c.violations = 0;
			c.violatedGClauses = new ArrayList<GClause>();
		}
		for(GClause f : clauses){
			calcNSAT(f);
			double c = f.cost();
			int kv = 0;
			if(c > 0){
				totalCost += c;
				for(int fc : f.fcid){
					Clause cl = mln.getClauseById(fc);
					boolean pen0 = cl.isPositiveClause();
					if(fc < 0) pen0 = !pen0;
					if(pen0 == (f.nsat == 0)){
						kv ++;
					}
				}
				if(kv > 0)	{
					for(int fc : f.fcid){
						Clause cl = mln.getClauseById(fc);
						boolean pen0 = cl.isPositiveClause();
						if(fc < 0) pen0 = !pen0;
						if(pen0 == (f.nsat == 0)){
							cl.cost += (c/kv);
							cl.violations += 1.0/kv;
							cl.violatedGClauses.add(f);
						}
					}
				}else{
					// System.err.println("found unaccounted-for ground clauses");
				}
			}
		}
	}

	/**
	 * Recalculate total cost.
	 * @return updated total cost
	 */
	public double recalcCost(){
		totalCost = 0;
		for(GClause f : clauses){
			calcNSAT(f);
			totalCost += f.cost();
		}
		return totalCost;
	}

	public double recalcCostNotOverrideOldCost(){
		double atotalCost = 0;
		for(GClause f : clauses){
			calcNSAT(f);
			atotalCost += f.cost();
		}
		return atotalCost;
	}

	public HashSet<Integer> getCoreAtoms() {
		return coreAtoms;
	}




	/****************************************
	 * MCSAT Below
	 ***************************************/


	/**
	 * This map records the expectation of #violation for
	 * each clause. This is filled by {@link MCSAT#calcExpViolation()}.
	 */
	public HashMap<String, Double> expectationOfViolation = null;

	/**
	 * This map records the expectation of square #violation for
	 * each clause. This is filled by {@link MCSAT#calcExpViolation()}.
	 */
	public HashMap<String, Double> expectationOfSquareViolation = null;

	/**
	 * This map records the tallies for calculating E(v_i*v_j).
	 */
	public HashMap<String, Long> clauseNiNjViolationTallies = null;

	/**
	 * This map records the expectation of E(v_i*v_j). 
	 * This is filled by {@link MCSAT#calcExpViolation()}.
	 */
	public HashMap<String, Double> expectationOfNiNjViolation = null;

	/**
	 * This array records the expection of #satisfaction for
	 * each clause. This is filled by {@link MCSAT#calcExpViolation()}.
	 */
	public HashMap<String, Double> expectationOfSatisfication = null;


	/**
	 * This array records total number of violation for a clause.
	 * Dividing this number by {@link MCSAT#nClauseVioTallies}
	 * will give the estimated expectation of #violation. 
	 */
	public HashMap<String, Long> clauseVioTallies = null;

	/**
	 * This array records total number of square violation for a clause.
	 * Dividing this number by {@link MCSAT#nClauseVioTallies}
	 * will give the estimated expectation of #violation. 
	 */
	public HashMap<String, Long> clauseSquareVioTallies = null;

	/**
	 * This array records total number of satisfaction for a clause.
	 */
	public HashMap<String, Long> clauseSatTallies = null;

	/**
	 * Number of iterations of tallies. 
	 */
	private int nClauseVioTallies = 0;

	/**
	 * Kill soft clauses.
	 * 
	 * @return the number of hard clauses
	 */
	public int retainOnlyHardClauses(){
		int numHard = 0;
		for(GClause c : clauses){
			if(c.isHardClause() == c.dead){
				c.dead = !c.dead;
			}
			if(!c.dead){
				++ numHard;
			}
		}
		totalAlive = numHard;
		return numHard;
	}

	/**
	 * SampleSAT (with WalkSAT inside), used to uniformly sample a zero-cost world.
	 * WalkSAT is used as a SAT solver to find the first (quasi-)zero-cost world.
	 * Simulated annealing (SA) is stochastically performed to wander around.
	 * @param nSteps
	 * 
	 * @return true iff a zero-cost world was reached
	 */
	public boolean sampleSAT(long nSteps){
		if(!Config.learning_mode)
			UIMan.println("    Running SampleSAT for " + UIMan.comma(nSteps) + " flips...");

		if(adj.isEmpty()) buildIndices();
		Random rand = new Random();

		initMRF();

		for(long flip = 1; flip <= nSteps; flip++){
			// check if we have reached terminal condition
			if(unsat.isEmpty()){
				saveLowTruth(totalCost);
				// // keep walking only if in sampleSAT mode
				if(Config.stop_samplesat_upon_sat)
					return true;
				if(!sampleSatMode || totalAlive == 0) return true;
			}
			// simulated annealing step
			boolean saStep = false;
			// id of atom to be flipped
			int picked = 0;

			/**
			 * pick an atom to flip in one of two ways:
			 * WalkSAT or SA
			 */
			if(sampleSatMode && (totalCost <= 0.0001 
					|| rand.nextDouble() <= 0.5) || unsat.isEmpty()){ 
				// SA step: randomly pick an atom
				GClause c = clauses.get(rand.nextInt(clauses.size()));
				picked = Math.abs(c.lits[0]);
				saStep = true;
			}else{
				// WalkSAT step

				GClause lucky = unsat.getRandomElement();
				if(lucky.isPositiveClause()){
					// a positive clause
					if(testChance(Config.walksat_random_step_probability)){
						// random flip
						picked = -1;
						while(picked == -1 || !ownsAtom(picked)){
							picked = Math.abs(lucky.lits[rand.nextInt(lucky.lits.length)]);
						}
					}else{
						// greedy flip
						double minDelta = Double.MAX_VALUE;
						int nrivals = 0;
						for(int lit : lucky.lits){
							int a = Math.abs(lit);
							if(!ownsAtom(a)) continue;
							if(atoms.get(a).delta() < minDelta){
								picked = a;
								minDelta = atoms.get(a).delta();
								nrivals = 1;
							}else if(atoms.get(a).delta() == minDelta){
								if(testChance(1.0/(++nrivals))){
									picked = a;
								}
							}
						}
					}
				}else{
					// a negative clause
					ArrayList<Integer> cands = new ArrayList<Integer>();
					for(int lit : lucky.lits){
						if(isTrueLit(lit) && ownsAtom(Math.abs(lit))){
							cands.add(Math.abs(lit));
						}
					}
					if(cands.size() == 1){
						picked = cands.get(0);
					}else{
						if(testChance(Config.walksat_random_step_probability)){
							picked = cands.get(rand.nextInt(cands.size()));
						}else{
							double minDelta = Double.MAX_VALUE;
							int nrivals = 0;
							for(int a : cands){
								// TODO: FIXED
								if(atoms.get(a).delta() < minDelta){
									picked = a;
									minDelta = atoms.get(a).delta();
									nrivals = 1;
								}else if(atoms.get(a).delta() == minDelta){
									if(testChance(1.0/(++nrivals))){
										picked = a;
									}
								}
							}
						}
					}
				}
			}
			if(picked == 0) continue;
			if(!ownsAtom(picked)) continue;
			GAtom atom = atoms.get(picked);
			if(atom.fixed) continue;
			if(Config.avoid_breaking_hard_clauses && 
					atom.criticalForHardClauses()) continue;
			if(Config.apply_greedy_throttling && 
					atom.delta() > 0 && 
					testChance(0.95)){
				continue;
			}


			// SA is just a filter to actual flipping
			if(saStep){
				if(rand.nextDouble() > Math.exp(-atom.delta()*Config.samplesat_sa_coef)){
					continue;
				}
			}

			/**
			 *  flip the picked atom
			 */
			totalCost += atom.delta();
			atom.truth = !atom.truth;
			dirtyAtoms.add(picked);
			atom.invertDelta();

			if(totalCost <= lowCost){
				saveLowTruth(totalCost);
			}

			// update stats
			ArrayList<GClause> tlfac, flfac;
			if(atom.truth){
				tlfac = adj.get(atom.id);
				flfac = adj.get(-atom.id);
			}else{
				flfac = adj.get(atom.id);
				tlfac = adj.get(-atom.id);
			}

			if(tlfac != null){
				for(GClause f : tlfac){
					///////////////////////////////////////////////
					// Ce flip the following two lines on Nov. 29
					///////////////////////////////////////////////
					++ f.nsat;
					if(f.dead) continue;

					int nsat = f.nsat;
					if(nsat==1){
						if(f.weight >= 0) {
							unsat.removeObj(f);
						}else{
							unsat.add(f);
						}
						for(int lit : f.lits){
							int a = Math.abs(lit);
							if(a==picked || !ownsAtom(a)) continue;
							atoms.get(a).revokeSatPotential(f);
						}
					}else if(nsat==2){
						for(int lit : f.lits){
							int a = Math.abs(lit);
							if(a==picked || !ownsAtom(a)) continue;
							GAtom n = atoms.get(a);
							if((lit>0) == n.truth && willChange(lit, f.lits)){
								n.revokeUnsatPotential(f);
								break;
							}
						}
					}
				}
			}
			if(flfac != null){
				for(GClause f : flfac){
					///////////////////////////////////////////////
					// Ce flip the following two lines on Nov. 29
					///////////////////////////////////////////////
					-- f.nsat;
					if(f.dead) continue;

					int nsat = f.nsat;
					if(nsat==0){
						if(f.weight <= 0) {
							unsat.removeObj(f);
						}else{
							unsat.add(f);
						}
						for(int lit : f.lits){
							int a = Math.abs(lit);
							if(a==picked || !ownsAtom(a)) continue;
							atoms.get(a).assignSatPotential(f);
						}
					}else if(nsat==1){
						for(int lit : f.lits){
							int a = Math.abs(lit);
							if(a==picked || !ownsAtom(a)) continue;
							GAtom n = atoms.get(a);
							if((lit>0) == n.truth && willChange(lit, f.lits)){
								n.assignUnsatPotential(f);
								break;
							}
						}
					}
				}
			}
		}
		return false;
	}

	public void updateAtomMarginalProbs(int numSamples){
		if(ownsAllAtoms){
			for(GAtom n : atoms.values()){
				n.prob = ((float)(n.tallyTrue)) / numSamples;
				//TODO: CHECK n.truth = (n.prob >= 0.5);
				//	n.truth = (n.prob >= 0.5);
				n.truth = true;
			}
		}else{
			for(int aid : getCoreAtoms()){
				GAtom n = atoms.get(aid);
				n.prob = ((float)(n.tallyTrue)) / numSamples;
				//	n.truth = (n.prob >= 0.5);
				n.truth = true;
			}
		}
	}

	/**
	 * For each atom, increment its truth tally by one if it's currently true.
	 */
	private void updateAtomTruthTallies(){
		if(ownsAllAtoms){
			for(GAtom n : atoms.values()){
				if(n.truth) n.tallyTrue++;
			}
		}else{
			for(int aid : getCoreAtoms()){
				GAtom n = atoms.get(aid);
				if(n.truth) n.tallyTrue++;
			}
		}
	}

	private void updateMLETallies(){

		BitSet queryTrueAtoms = new BitSet(atoms.size() + 1);

		if(ownsAllAtoms){
			for(GAtom n : atoms.values()){
				if(n.isquery && n.truth){
					queryTrueAtoms.set(n.id);
				}
			}
		}else{
			for(int aid : getCoreAtoms()){
				GAtom n = atoms.get(aid);
				if(n.isquery && n.truth){
					queryTrueAtoms.set(n.id);
				}
			}
		}

		if(!mleTallies.containsKey(queryTrueAtoms)){

			mleTallies.put(queryTrueAtoms, new myInt(0));


		}

		mleTallies.get(queryTrueAtoms).addOne();

	}

	private void resetAtomTruthTallies(){
		if(ownsAllAtoms){
			for(GAtom n : atoms.values()){
				n.tallyTrue = 0;
			}
		}else{
			for(int aid : getCoreAtoms()){
				GAtom n = atoms.get(aid);
				n.tallyTrue = 0;
			}
		}
	}

	private void resetMLETallies(){
		mleTallies.clear();
	}

	private int mcsatTotalSamples = 0;

	public boolean isPowerOfTwo(int n){
		return ((n!=0) && (n&(n-1))==0);
	}

	/**
	 * Execute the MC-SAT algorithm.
	 * @param numSamples number of MC-SAT samples
	 * @param numFlips number of SampleSAT steps in each iteration
	 */
	@SuppressWarnings("unused")
	public double mcsat(int numSamples, long numFlips, DataMover... dmovers){

		if (!Config.mcsat_cumulative) resetAtomTruthTallies();
		initStrategy = INIT_STRATEGY.COIN_FLIP;
		if(!Config.learning_mode) Config.stop_samplesat_upon_sat = true;
		UIMan.println(">>> Running MC-SAT for " + numSamples + " samples...");
		// init
		sampleSatMode = false;

		boolean isFirstTime = true;

		if(isFirstTime && !Config.snapshoting_so_do_not_do_init_flip){
			UIMan.verbose(1, ">>> MC-SAT INIT: running WalkSAT on hard clauses...");
			int x = retainOnlyHardClauses();
			UIMan.verbose(1, "### hard clauses = " + x);
			sampleSAT(numFlips);
		}

		if(!Config.snapshoting_so_do_not_do_init_flip){
			isFirstTime = false;
			enableAllClauses();
			restoreLowTruth();
		}

		sampleSatMode = true;
		// clear tallies of clauses.
		this.nClauseVioTallies = 0;
		this.clauseVioTallies = null;
		this.clauseSatTallies = null;
		this.expectationOfViolation = null;
		this.expectationOfSatisfication = null;
		this.clauseSquareVioTallies = null;
		this.expectationOfSquareViolation = null;
		this.clauseNiNjViolationTallies = null;
		this.expectationOfNiNjViolation = null;

		double time = 0;

		int dumpingTime = 0;
		int lastTime = (int)Timer.elapsedSeconds();

		HashSet<Integer> historyTime = new HashSet<Integer>();

		double sumCost = 0;
		int nSample = numSamples;
		int size = this.atoms.size();
		double knob = Math.pow(2, this.atoms.size()+1);

		HashSet<Integer> history_po2 = new HashSet<Integer>();

		double maxWeight = Double.NEGATIVE_INFINITY;
		double treeWidth = 0;
		double avgDegree = 0;
		if(Config.sampleLog != null){
			for(GClause gc : this.clauses){
				if(maxWeight <= gc.weight){
					maxWeight = gc.weight;
				}
			}
			this.buildIndices();
			int nn = 0;
			int nneigh = 0;
			for(Integer atom : this.adj.keySet()){
				nn += 1;
				nneigh +=this.adj.get(atom).size();
			}
			avgDegree = 1.0*nneigh/nn;
			DS_JunctionTree jt = new DS_JunctionTree(this);
			treeWidth = jt.getTreeWidth();
		}

		// sample
		for(int i=1; i<=numSamples; i++){


			if(Config.sampleLog != null){
				Timer.start(this + "aaa");
			}

			if(Config.learning_mode)
				UIMan.print("*");
			else
				UIMan.println(">>> MC-SAT Sample #" + i + "");
			sumCost += performMCSatStep(numFlips);
			int curTime = (int) Timer.elapsedSeconds();

			if(Config.sampleLog != null){
				time += Timer.elapsedMilliSeconds(this + "aaa");
			}

			/* Cannot handle parallel processors...
			if (Config.mcsat_dump_interval>0 && i%Config.mcsat_dump_interval==0) {
				String fout = "tuffy.mcsat.results.samples." + i;
				UIMan.println("MCSAT-SAMPLE-" + i + ": " + (curTime-dumpingTime) + " " + Timer.elapsed());
				UIMan.println("Writing MCSAT result to file " + fout);

				updateAtomMarginalProbs(i);
				dmovers[0].flushAtomStates(this.atoms.values(), mln.relAtoms);
				dmovers[0].dumpProbsToFile(mln.relAtoms, fout);
			}
			 */

			if(dmovers.length == 1){
				boolean timeDump = false;

				if(timeDump && (i < 100  || 
						(Math.abs(((curTime - dumpingTime) % 100)) < 5 && 
								!historyTime.contains(curTime - dumpingTime)))){
					historyTime.add(curTime - dumpingTime);
					String fout = "tuffy.mcsat.results.samples." + i + ".seconds." + (curTime - dumpingTime);
					UIMan.println("MCSAT-SAMPLE-" + i + ": " + (curTime-dumpingTime) + " " + Timer.elapsed());
					UIMan.println("Writing MCSAT result to file " + fout);

					updateAtomMarginalProbs(mcsatTotalSamples + i);
					dmovers[0].flushAtomStates(this.atoms.values(), mln.relAtoms);
					dmovers[0].dumpProbsToFile(mln.relAtoms, fout);

					int aTime = (int)Timer.elapsedSeconds();
					dumpingTime += (aTime - curTime);
				}
			}


			if(Config.sampleLog != null){
				if( Math.log10(i) == (int)Math.log10(i)
						|| (i % (nSample/100) == 0) 
						|| isPowerOfTwo(nSample/i)){

					String sig = "";
					if(isPowerOfTwo(nSample/i)){
						sig += "exp" + (nSample/i) + "|";
					}

					if(Math.log10(i) == (int)Math.log10(i)){
						sig += "log10|";
					}

					if((i%100 == 0 && (i/100) % size == 0)){
						sig += "linear|";
					}

					if(history_po2.contains(nSample/i) && sig.equals("exp" + (nSample/i) + "|")){
						continue;
					}
					history_po2.add(nSample/i);

					for(GAtom atom : this.atoms.values()){

						Config.sampleLog.println(
								//System.out.println(
								i + "\t" + 
								sig + "\t" + 
								"tuffy.sample.SampleAlgorithm_MCSAT" + "\t" + 
								this.atoms.size() + "\t" +
								time + "\t" +
								atom.id + "\t" +
								atom.pid + "\t" + 
								"-1" + "\t" +
								"-1" + "\t" + 
								atom.tallyTrue + "\t" +
								i + "\t" +
								"-1" + "\t" + 
								1.0*atom.tallyTrue/i + "\t" + 
								maxWeight + "\t" + 
								treeWidth + "\t" + 
								avgDegree
								);
					}
				}


			}


		}

		if(Config.learning_mode){
			this.calcExpViolation();
		}

		if (Config.mcsat_cumulative) {
			mcsatTotalSamples += numSamples;
			updateAtomMarginalProbs(mcsatTotalSamples);
		} else {
			updateAtomMarginalProbs(numSamples);
		}


		return sumCost;
	}

	public void updateAtomTruthFromMLE(ArrayList<BitSetIntPair> samples){

		for(BitSetIntPair top : samples){

			BitSet truthset = top.bitset;
			int freq = top.integer;

			if(this.ownsAllAtoms){
				for(Integer atom : this.atoms.keySet()){
					if(truthset.get(atom)){
						this.atoms.get(atom).truth = true;
						if(Config.mleTopK != -1){
							this.atoms.get(atom).top_truth_cache.add(true);
						}
					}else{
						this.atoms.get(atom).truth = false;
						if(Config.mleTopK != -1){
							this.atoms.get(atom).top_truth_cache.add(false);
						}
					}
				}
			}else{
				for(Integer atom : this.coreAtoms){
					if(truthset.get(atom)){
						this.atoms.get(atom).truth = true;
						if(Config.mleTopK != -1){
							this.atoms.get(atom).top_truth_cache.add(true);
						}
					}else{
						this.atoms.get(atom).truth = false;
						if(Config.mleTopK != -1){
							this.atoms.get(atom).top_truth_cache.add(false);
						}
					}
				}
			}

			if(Config.mleTopK == -1){
				break;
			}
		}

	}

	boolean isMLE = false;

	public double mle_naiveMCMC(int numSamples, long numFlips, 
			ArrayList<BitSetIntPair> mle_rs_cache, DataMover... dmovers){

		isMLE = true;

		if (!Config.mcsat_cumulative) resetAtomTruthTallies();
		initStrategy = INIT_STRATEGY.COIN_FLIP;
		if(!Config.learning_mode) Config.stop_samplesat_upon_sat = true;
		UIMan.println(">>> Running MC-SAT for " + numSamples + " samples...");
		// init
		sampleSatMode = false;

		boolean isFirstTime = true;

		isFirstTime = false;
		enableAllClauses();
		restoreLowTruth();

		sampleSatMode = true;

		// clear tallies of clauses.
		this.nClauseVioTallies = 0;
		this.clauseVioTallies = null;
		this.clauseSatTallies = null;
		this.expectationOfViolation = null;
		this.expectationOfSatisfication = null;
		this.clauseSquareVioTallies = null;
		this.expectationOfSquareViolation = null;
		this.clauseNiNjViolationTallies = null;
		this.expectationOfNiNjViolation = null;

		int dumpingTime = 0;
		int lastTime = (int)Timer.elapsedSeconds();

		HashSet<Integer> historyTime = new HashSet<Integer>();

		double sumCost = 0;

		// sample
		for(int i=1; i<=numSamples; i++){
			if(Config.learning_mode)
				UIMan.print("*");
			else
				UIMan.println(">>> MC-SAT Sample #" + i + "");
			sumCost += performMCSatStep(numFlips);
			int curTime = (int) Timer.elapsedSeconds();

			if(dmovers.length == 1){
				boolean timeDump = false;

				if(timeDump && (i < 100  || 
						(Math.abs(((curTime - dumpingTime) % 100)) < 5 && 
								!historyTime.contains(curTime - dumpingTime)))){
					historyTime.add(curTime - dumpingTime);
					String fout = "tuffy.mcsat.results.samples." + i + ".seconds." + (curTime - dumpingTime);
					UIMan.println("MCSAT-SAMPLE-" + i + ": " + (curTime-dumpingTime) + " " + Timer.elapsed());
					UIMan.println("Writing MCSAT result to file " + fout);

					updateAtomMarginalProbs(mcsatTotalSamples + i);
					dmovers[0].flushAtomStates(this.atoms.values(), mln.relAtoms);
					dmovers[0].dumpProbsToFile(mln.relAtoms, fout);

					int aTime = (int)Timer.elapsedSeconds();
					dumpingTime += (aTime - curTime);
				}
			}

		}

		int max = 0;
		BitSet maxkey = null;

		if(mle_rs_cache == null){
			mle_rs_cache = new ArrayList<BitSetIntPair>();
		}

		for(BitSet key : mleTallies.keySet()){

			mle_rs_cache.add(new BitSetIntPair(key, mleTallies.get(key).value));

		}

		Collections.sort(mle_rs_cache, Collections.reverseOrder());

		updateAtomTruthFromMLE(mle_rs_cache);

		return sumCost;
	}




	/**
	 * Update the number of violations of a clause. For each GClause, their
	 * value can increase at most 1 for each MCSAT iteration. For Clause,
	 * their value can increase more, because there may be more than one
	 * GClauses associated with it. 
	 */
	public void updateClauseVoiTallies(){

		// at least one clause in this system
		// assert(GClause.maxFCID >= 0);

		if(this.clauseVioTallies == null){
			this.clauseVioTallies = new HashMap<String, Long>();
			this.clauseSatTallies = new HashMap<String, Long>();
			this.clauseSquareVioTallies = new HashMap<String, Long>();
			this.clauseNiNjViolationTallies = new HashMap<String, Long>();
			//this.nGClauseEachClause = new HashMap<String, Long>();
		}
		HashMap<String, Long> tmpSquareViolation = new HashMap<String, Long>();

		this.nClauseVioTallies ++ ;

		// HERE THE METHOD FOR CALCULATION OF UNSATISFIED GCLAUSE
		// CAN BE INFLUENCED BY CE'S CHANGE IN FUNCTION SAMPLESAT().
		for(GClause c : clauses){

			if(c.ffcid[0].equals("4.0") && c.nsat==0){
				//System.out.print("");
			}

			if( c.nsat == 0){
				// This GClause == false.
				for(String cid : c.ffcid){
					String newCID = cid;
					if(newCID.charAt(0) == '-'){
						newCID = newCID.substring(1, newCID.length());
						if( -Learner.currentWeight.get(newCID) > 0 ){
							// -x is po2.0=11sitive clause
							// => -x is violated
							// => x is violated
							Long tmp = this.clauseVioTallies.get(newCID);
							if(tmp == null) tmp = 0l;
							this.clauseVioTallies.put(newCID, tmp+1);

							tmp = tmpSquareViolation.get(newCID);
							if(tmp == null) tmp = 0l;
							tmpSquareViolation.put(newCID, tmp+1);

							tmp = this.clauseSatTallies.get(newCID);
							if(tmp == null)
								this.clauseSatTallies.put(newCID, 0l);
						}else{
							// -x is negative clause
							// => -x is satisfied
							// => x is satisfied
							Long tmp = this.clauseSatTallies.get(newCID);
							if(tmp == null) tmp = 0l;
							this.clauseSatTallies.put(newCID, tmp+1);

							tmp = this.clauseVioTallies.get(newCID);
							if(tmp == null)
								this.clauseVioTallies.put(newCID, 0l);

							tmp = tmpSquareViolation.get(newCID);
							if(tmp == null)
								tmpSquareViolation.put(newCID, 0l);
						}	
					}else{
						if( Learner.currentWeight.get(newCID) > 0 ){
							// x is positive clause
							// => x is violated
							Long tmp = this.clauseVioTallies.get(newCID);
							if(tmp == null) tmp = 0l;
							this.clauseVioTallies.put(newCID, tmp+1);

							tmp = tmpSquareViolation.get(newCID);
							if(tmp == null) tmp = 0l;
							tmpSquareViolation.put(newCID, tmp+1);

							tmp = this.clauseSatTallies.get(newCID);
							if(tmp == null)
								this.clauseSatTallies.put(newCID, 0l);
						}else{
							// x is negative clause
							// => x is satisfied
							Long tmp = this.clauseSatTallies.get(newCID);
							if(tmp == null) tmp = 0l;
							this.clauseSatTallies.put(newCID, tmp+1);

							tmp = this.clauseVioTallies.get(newCID);
							if(tmp == null)
								this.clauseVioTallies.put(newCID, 0l);

							tmp = tmpSquareViolation.get(newCID);
							if(tmp == null)
								tmpSquareViolation.put(newCID, 0l);
						}	
					}
				}
			}else{
				// This GClause == true.
				for(String cid : c.ffcid){
					String newCID = cid;
					if(newCID.charAt(0) == '-'){
						newCID = newCID.substring(1, newCID.length());
						if( -Learner.currentWeight.get(newCID) > 0 ){
							// -x is positive clause
							// => -x is satisfied
							// => x is satisfied
							Long tmp = this.clauseSatTallies.get(newCID);
							if(tmp == null) tmp = 0l;
							this.clauseSatTallies.put(newCID, tmp+1);

							tmp = this.clauseVioTallies.get(newCID);
							if(tmp == null)
								this.clauseVioTallies.put(newCID, 0l);

							tmp = tmpSquareViolation.get(newCID);
							if(tmp == null)
								tmpSquareViolation.put(newCID, 0l);
						}else{
							// -x is negative clause
							// => -x is violated
							// => x is violated
							Long tmp = this.clauseVioTallies.get(newCID);
							if(tmp == null) tmp = 0l;
							this.clauseVioTallies.put(newCID, tmp+1);

							tmp = tmpSquareViolation.get(newCID);
							if(tmp == null) tmp = 0l;
							tmpSquareViolation.put(newCID, tmp+1);

							tmp = this.clauseSatTallies.get(newCID);
							if(tmp == null)
								this.clauseSatTallies.put(newCID, 0l);
						}	
					}else{
						if( Learner.currentWeight.get(newCID) > 0 ){
							// x is positive clause
							// => x is satisfied
							Long tmp = this.clauseSatTallies.get(newCID);
							if(tmp == null) tmp = 0l;
							this.clauseSatTallies.put(newCID, tmp+1);

							tmp = this.clauseVioTallies.get(newCID);
							if(tmp == null)
								this.clauseVioTallies.put(newCID, 0l);

							tmp = tmpSquareViolation.get(newCID);
							if(tmp == null)
								tmpSquareViolation.put(newCID, 0l);
						}else{
							// x is negative clause
							// => x is violated
							Long tmp = this.clauseVioTallies.get(newCID);
							if(tmp == null) tmp = 0l;
							this.clauseVioTallies.put(newCID, tmp+1);

							tmp = tmpSquareViolation.get(newCID);
							if(tmp == null) tmp = 0l;
							tmpSquareViolation.put(newCID, tmp+1);

							tmp = this.clauseSatTallies.get(newCID);
							if(tmp == null)
								this.clauseSatTallies.put(newCID, 0l);
						}	
					}
				}

			}
		}

		for(String cid : tmpSquareViolation.keySet()){
			Long value = tmpSquareViolation.get(cid);
			Long tmp = this.clauseSquareVioTallies.get(cid);
			if(tmp == null){
				this.clauseSquareVioTallies.put(cid, value*value);
			}else{
				this.clauseSquareVioTallies.put(cid, tmp + value*value);
			}
		}

		for(String cid1 : tmpSquareViolation.keySet()){
			Long value1 = tmpSquareViolation.get(cid1);
			for(String cid2 : tmpSquareViolation.keySet()){
				Long value2 = tmpSquareViolation.get(cid2);
				Long tmp = this.clauseNiNjViolationTallies.get(cid1+","+cid2);
				if(tmp == null){
					this.clauseNiNjViolationTallies.put(cid1+","+cid2, value1*value2);
				}else{
					this.clauseNiNjViolationTallies.put(cid1+","+cid2, tmp + value1*value2);
				}
			}
		}

	}

	/**
	 * Calculating the different expectations by filling the HashMaps related to
	 * expectations in this class.
	 */
	public void calcExpViolation(){
		// has run updateClauseVoiTallies() before
		assert(this.clauseVioTallies != null);
		assert(this.nClauseVioTallies > 0);

		this.expectationOfViolation = new HashMap<String, Double>();
		this.expectationOfSatisfication = new HashMap<String, Double>();
		this.expectationOfSquareViolation = new HashMap<String, Double>();
		this.expectationOfNiNjViolation = new HashMap<String, Double>();

		for(String k : this.clauseVioTallies.keySet()){
			this.expectationOfViolation.put(k, 
					((double)this.clauseVioTallies.get(k)) / this.nClauseVioTallies);
			this.expectationOfSatisfication.put(k, 
					((double)this.clauseSatTallies.get(k)) / this.nClauseVioTallies);
			this.expectationOfSquareViolation.put(k, 
					((double)this.clauseSquareVioTallies.get(k)) / this.nClauseVioTallies );
		}

		for(String k : this.clauseNiNjViolationTallies.keySet()){
			this.expectationOfNiNjViolation.put(k, 
					((double)this.clauseNiNjViolationTallies.get(k)) 
					/ this.nClauseVioTallies);
		}
	}


	/**
	 * Change the weight of GClause based on updated weight
	 * of Clause. This new weight will be aware by MCSAT. The
	 * cost of flipping atom and the unsat set for GClause will
	 * be calculated automatically by this function.
	 * 
	 * @param currentWeight The weight of clauses to be flushed
	 * in this MCSAT instance.
	 */
	public void updateClauseWeights(HashMap<String, Double> currentWeight){
		for(GClause c : this.clauses){
			String[] ffcid = c.ffcid;
			c.weight = 0;
			for(int i=0;i<ffcid.length;i++){
				String newCID = ffcid[i];
				int signal = 1;
				if(newCID.charAt(0) == '-'){
					newCID = newCID.substring(1, newCID.length());
					signal = -1;
				}

				// TODO: HERE IS THE HARD-CLAUSE TRICK. CHECK WHETHER
				// WE NEED IT.
				// it is almost impossible for a non-zero-violation
				// clause to have such a big value...
				//if(currentWeight.get(newCID)*signal > 19){
				//	Learner.isHardMappings.put(newCID, true);
				//	c.weight = Config.hard_weight + 100;
				//	break;
				//}else
				c.weight += currentWeight.get(newCID) * signal;
			}
		}
		calcCosts();
		buildIndices();
	}

	/**
	 * Perform one sample of MC-SAT
	 * @param numFlips number of sampleSAT flips
	 */
	public double performMCSatStep(long numFlips){

		this.invalidateLowCost();

		retainSomeGoodClauses();
		// TODO: CURRENTLY, CE FINDS ADDING THIS FUNCTION
		// MAY INFLUENCE THE SPEED OF SAMPLESAT. CHECK IT
		// IN THE FUTURE
		// unitPropagation();

		sampleSAT(numFlips);

		unfixAllAtoms();
		enableAllClauses();
		restoreLowTruth();

		if(isMLE){
			updateMLETallies();
		}else{
			updateAtomTruthTallies();
		}

		this.recalcCost();

		if(Config.learning_mode){
			updateClauseVoiTallies();
		}

		return this.getCost();

	}


	/**
	 * Try to satisfy as many clauses as possible with unit propagation.
	 * Used as a preprocessing step of SampleSAT, which tries to uniformly 
	 * sample among all zero-cost worlds.
	 */
	@SuppressWarnings("unused")
	private void unitPropagation(){
		/**
		 *  Satisfy negative clauses.
		 *  We have to make sure all literals are false.
		 */
		for(GClause cee : clauses){
			if(cee.dead || cee.isPositiveClause()) continue;
			if(isAlwaysTrue(cee)) continue;
			for(int lit : cee.lits){
				if(lit > 0){
					fixAtom(lit, false);
				}else{
					fixAtom(-lit, true);
				}
			}
		}

		/**
		 *  Propagate to positive clauses.
		 *  We only need to fix one literal of each positive clause.
		 *  Keep sweeping the clauses until no fixing can be done in the whole round.
		 *  TODO: improve the efficiency of this procedure
		 */
		boolean done = false;
		while(!done){
			done = true;
			for(GClause cee : clauses){
				if(cee.dead || !cee.isPositiveClause()) continue;
				if(isAlwaysTrue(cee)) continue;

				int numCand = 0, lastCand = 0;
				for(int lit : cee.lits){
					GAtom atom = atoms.get(Math.abs(lit));
					if(!atom.fixed){
						lastCand = lit;
						numCand ++;
						if(numCand > 1) break;
					}
				}
				if(numCand == 1){
					fixAtom(Math.abs(lastCand), lastCand>0);
					done = false;
				}
			}
		}
	}



	/*
	public class myInt{

		int value;

		public myInt(int _value){
			value = _value;
		}

		public void addOne(){
			value ++;
		}

		public void add(int _v){
			value += _v;
		}

		public int getValue(){
			return value;
		}

	}
	 */


}
